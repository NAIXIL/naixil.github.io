<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"naixil.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="与遗忘作斗争">
<meta property="og:type" content="website">
<meta property="og:title" content="LiXian&#39;s Blog">
<meta property="og:url" content="https://naixil.github.io/page/2/index.html">
<meta property="og:site_name" content="LiXian&#39;s Blog">
<meta property="og:description" content="与遗忘作斗争">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Li Xian">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://naixil.github.io/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>LiXian's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">LiXian's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://naixil.github.io/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/0%E6%95%B0%E6%8D%AE%E5%BA%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Li Xian">
      <meta itemprop="description" content="与遗忘作斗争">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LiXian's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/0%E6%95%B0%E6%8D%AE%E5%BA%93/" class="post-title-link" itemprop="url">数据库</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-09-01 12:08:43" itemprop="dateCreated datePublished" datetime="2021-09-01T12:08:43+08:00">2021-09-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-09-15 10:56:45" itemprop="dateModified" datetime="2021-09-15T10:56:45+08:00">2021-09-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/" itemprop="url" rel="index"><span itemprop="name">计算机基础知识总结</span></a>
                </span>
            </span>

          
            <span id="/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/0%E6%95%B0%E6%8D%AE%E5%BA%93/" class="post-meta-item leancloud_visitors" data-flag-title="数据库" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/0%E6%95%B0%E6%8D%AE%E5%BA%93/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/0%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>20k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>18 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="docker中运行mySQL"><a href="#docker中运行mySQL" class="headerlink" title="docker中运行mySQL"></a>docker中运行mySQL</h1><h2 id="拉取容器：docker-pull-mysql-latest"><a href="#拉取容器：docker-pull-mysql-latest" class="headerlink" title="拉取容器：docker pull mysql:latest"></a>拉取容器：<code>docker pull mysql:latest</code></h2><h2 id="运行容器"><a href="#运行容器" class="headerlink" title="运行容器"></a>运行容器</h2><p><code>docker run -p 3306:3306 --name mysql -e MYSQL_ROOT_PASSWORD=123456 -d mysql:latest</code></p>
<h2 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h2><h3 id="普通登录方法"><a href="#普通登录方法" class="headerlink" title="普通登录方法"></a>普通登录方法</h3><p><code>docker exec -it mysql bash</code></p>
<h3 id="支持中文格式的登录方法"><a href="#支持中文格式的登录方法" class="headerlink" title="支持中文格式的登录方法"></a>支持中文格式的登录方法</h3><p><code>docker exec -it mysql env LANG=C.UTF-8 bash</code></p>
<h2 id="容器内登录mysql"><a href="#容器内登录mysql" class="headerlink" title="容器内登录mysql"></a>容器内登录mysql</h2><h3 id="普通登录"><a href="#普通登录" class="headerlink" title="普通登录"></a>普通登录</h3><p><code>mysql -u root -p</code>$\rightarrow$输入密码123456即可</p>
<h3 id="需要导入数据时登录方法"><a href="#需要导入数据时登录方法" class="headerlink" title="需要导入数据时登录方法"></a>需要导入数据时登录方法</h3><p><code>mysql --local-infile=1 -h 127.0.0.1 -u root -p </code></p>
<h2 id="容器启停"><a href="#容器启停" class="headerlink" title="容器启停"></a>容器启停</h2><ol>
<li><code>docker ps -a</code> 获取容器ID和名字，查看状态、<ul>
<li>如果是Exit<ul>
<li><code>docker start ID/Name</code></li>
<li><code>docker exec -it Name bash</code>进入容器</li>
</ul>
</li>
</ul>
</li>
<li><code>docker stop ID/Name</code></li>
<li><code>docker restart ID/Name</code></li>
</ol>
<h2 id="docker上传文件到容器"><a href="#docker上传文件到容器" class="headerlink" title="docker上传文件到容器"></a>docker上传文件到容器</h2><ul>
<li><code>docker cp 本地文件路径 ID全称:容器路径</code><ul>
<li><code>docker cp /mnt/c/Codes/Datasets/mySQL/student.txt mysql:/usr</code></li>
</ul>
</li>
</ul>
<h2 id="docker的mysql不支持中文"><a href="#docker的mysql不支持中文" class="headerlink" title="docker的mysql不支持中文"></a>docker的mysql不支持中文</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;export LANG=C.UTF-8&quot; &gt;&gt;/etc/profile &amp;&amp; source /etc/profile</span><br></pre></td></tr></table></figure>

<img src="/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/0%E6%95%B0%E6%8D%AE%E5%BA%93/image-20210822172021597.png" alt="image-20210822172021597" style="zoom: 25%;">


<h1 id="数据库系统概论（王珊、萨师煊）"><a href="#数据库系统概论（王珊、萨师煊）" class="headerlink" title="数据库系统概论（王珊、萨师煊）"></a>数据库系统概论（王珊、萨师煊）</h1><h2 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h2><ol>
<li>4个基本概念：DBS=DBMS+DB+DBA+应用<ol>
<li>数据库</li>
<li>数据<ol>
<li>按一定数据模型组织、描述和储存</li>
<li>可共享、冗余度小、易扩展</li>
<li>数据独立性高</li>
</ol>
</li>
<li>数据库管理系统：组织、存储数据；获取、维护数据<ol>
<li>功能<ol>
<li>数据定义</li>
<li>数据组织、存储和管理</li>
<li>数据操纵</li>
<li>数据库事务管理和运行管理</li>
<li>数据库建立与维护</li>
<li>其它</li>
</ol>
</li>
</ol>
</li>
<li>数据库系统<ol>
<li>特点<ol>
<li>数据结构化：变长数据；最小数据存取单位：数据项</li>
<li>数据共享性高、冗余度低</li>
<li>数据独立性高</li>
<li>由DBMS统一管理与控制</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>数据模型：DBMS的核心与基础；由数据结构、数据操作、完整性约束组成；<ol>
<li>概念模型/信息模型：按数据建模，用于数据库设计<ol>
<li>实体</li>
<li>属性</li>
<li>码</li>
<li>实体型（Entity Type）:学生（学号，姓名）</li>
<li>实体集（Entity Set）：全体学生</li>
<li>联系：1:1,1:n,m:n</li>
<li>表示：E-R图</li>
</ol>
</li>
<li>逻辑模型和物理模型<ol>
<li>格式化模型<ol>
<li>层次模型：有且只有一个根，除根之外有且只有一个双亲<ul>
<li>特点：只可以一对多；查询子女必须经过双亲</li>
</ul>
</li>
<li>网状模型：允许一个以上的结点无双亲；一个结点可以多个双亲</li>
</ol>
</li>
<li>关系模型<ul>
<li>缺点：查询效率小于格式化模型；必须进行查询优化</li>
</ul>
</li>
<li>对象模型：面向对象模型；对象关系模型</li>
</ol>
</li>
<li>查询效率：层次&gt;关系；层次&gt;=网状</li>
</ol>
</li>
</ol>
<img src="/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/0%E6%95%B0%E6%8D%AE%E5%BA%93/IMG_20210830_235839.jpg" alt="IMG_20210830_235839" style="zoom: 25%;">

<h2 id="关系数据库"><a href="#关系数据库" class="headerlink" title="关系数据库"></a>关系数据库</h2><img src="/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/0%E6%95%B0%E6%8D%AE%E5%BA%93/IMG_20210830_235913.jpg" alt="IMG_20210830_235913" style="zoom:25%;">



<img src="/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/0%E6%95%B0%E6%8D%AE%E5%BA%93/IMG_20210830_235929.jpg" alt="IMG_20210830_235929" style="zoom:25%;">



<img src="/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/0%E6%95%B0%E6%8D%AE%E5%BA%93/IMG_20210830_235940.jpg" alt="IMG_20210830_235940" style="zoom:25%;">





<img src="/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/0%E6%95%B0%E6%8D%AE%E5%BA%93/IMG_20210831_000000.jpg" alt="IMG_20210831_000000" style="zoom:25%;">



<h2 id="SQL语言"><a href="#SQL语言" class="headerlink" title="SQL语言"></a>SQL语言</h2><h3 id="SQL概述"><a href="#SQL概述" class="headerlink" title="SQL概述"></a>SQL概述</h3><h3 id="从mysql导入数据"><a href="#从mysql导入数据" class="headerlink" title="从mysql导入数据"></a>从mysql导入数据</h3><p>命令行界面下：</p>
<ul>
<li><code>load data local infile &#39;/usr/student.txt&#39; into table student lines terminated by  &#39;\r\n&#39;;</code>用记事本写，一行为一个元组，分隔符是TAB</li>
</ul>
<h3 id="数据定义"><a href="#数据定义" class="headerlink" title="数据定义"></a>数据定义</h3><h4 id="模式的定义与删除"><a href="#模式的定义与删除" class="headerlink" title="模式的定义与删除"></a>模式的定义与删除</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">create schema &lt;模式名&gt;;</span><br><span class="line">drop schema &lt;模式名&gt; &lt;CASCADE | RESTRICT&gt;;  -- CASCADE（删除模式的时候把模式下的数据库对象（表、视图）都删除）RESTRICT（模式下有数据库对象则拒绝删除）必须2选1</span><br></pre></td></tr></table></figure>

<h4 id="基本表的定义、删除与修改"><a href="#基本表的定义、删除与修改" class="headerlink" title="基本表的定义、删除与修改"></a>基本表的定义、删除与修改</h4><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><ul>
<li><p>每个基本表都属于一个模式，一个模式包含多个基本表。</p>
</li>
<li><p>定义基本表的时候定义其所属模式</p>
<ul>
<li><p>在表名中明显的给出模式名</p>
<ul>
<li>```<br>CREATE TABLE “S-T”.Student(…)；  –Student表所属的模式是S-T<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">- 创建模式的时候创建表</span><br><span class="line"></span><br><span class="line">    - ```</span><br><span class="line">      CREATE SCHEMA TEST</span><br><span class="line">      CREATE TABLE Student(...)；</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>设置所属模式（根据设置好的搜索路径</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">create table Student</span><br><span class="line">(Sno CHAR(9) PRIMARY KEY,  -- 设置主键/主码，不能为空</span><br><span class="line">Sname VARCHAR(20) UNIQUE,  -- 不能重复出现</span><br><span class="line">Ssex CHAR(2),</span><br><span class="line">Sage TINYINT,</span><br><span class="line">Sdept VARCHAR(20));</span><br><span class="line">/*</span><br><span class="line">+-----------+-------+------+------+-------+------------+</span><br><span class="line">| Sno       | Sname | Ssex | Sage | Sdept | S_entrance |</span><br><span class="line">+-----------+-------+------+------+-------+------------+</span><br><span class="line">| 201215121 | 李勇  | 男   |   20 | CS    | NULL       |</span><br><span class="line">| 201215122 | 刘晨  | 女   |   19 | CS    | NULL       |</span><br><span class="line">| 201215123 | 王敏  | 女   |   18 | MA    | NULL       |</span><br><span class="line">| 201215125 | 张立  | 男   |   19 | IS    | NULL       |</span><br><span class="line">+-----------+-------+------+------+-------+------------+</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">create table Course</span><br><span class="line">(Cno CHAR(4) PRIMARY KEY,</span><br><span class="line"> Cname CHAR(40) NOT NULL,  -- 不能取空值</span><br><span class="line"> Cpno CHAR(4),</span><br><span class="line"> Ccredit SMALLINT,</span><br><span class="line"> FOREIGN KEY (Cpno) REFERENCES Course(Cno));  -- Cpno是外码，被参照表是Course，被参照列是Cno</span><br><span class="line">/*</span><br><span class="line">+-----+----------+------+---------+</span><br><span class="line">| Cno | Cname    | Cpno | Ccredit |</span><br><span class="line">+-----+----------+------+---------+</span><br><span class="line">| 1   | 数据库   | 5    |       4 |</span><br><span class="line">| 2   | 数学     | NULL |       2 |</span><br><span class="line">| 3   | 信息系统 | 1    |       4 |</span><br><span class="line">| 4   | 操作系统 | 6    |       3 |</span><br><span class="line">| 5   | 数据结构 | 7    |       4 |</span><br><span class="line">| 6   | 数据处理 | NULL |       2 |</span><br><span class="line">| 7   | C语言    | 4    |       6 |</span><br><span class="line">+-----+----------+------+---------+</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">create table SC</span><br><span class="line">(Sno CHAR(9), </span><br><span class="line"> Cpno CHAR(4),</span><br><span class="line"> Grade SMALLINT,</span><br><span class="line"> PRIMARY KEY (Sno,Cno)  -- 两个主码</span><br><span class="line"> FOREIGN KEY (Sno) REFERENCES Student(Sno)),</span><br><span class="line"> FOREIGN KEY (Cpno) REFERENCES Course(Cno)));</span><br><span class="line"> /*</span><br><span class="line"> +-----------+-----+-------+</span><br><span class="line">| Sno       | Cno | Grade |</span><br><span class="line">+-----------+-----+-------+</span><br><span class="line">| 201215121 | 1   |    92 |</span><br><span class="line">| 201215121 | 2   |    85 |</span><br><span class="line">| 201215121 | 3   |    88 |</span><br><span class="line">| 201215122 | 2   |    90 |</span><br><span class="line">| 201215122 | 3   |    80 |</span><br><span class="line">+-----------+-----+-------+</span><br><span class="line">*/ </span><br></pre></td></tr></table></figure>

<h5 id="更改属性的数据类型、值"><a href="#更改属性的数据类型、值" class="headerlink" title="更改属性的数据类型、值"></a>更改属性的数据类型、值</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE &lt;表名&gt;</span><br><span class="line">[ADD [COLUMN] &lt;列名&gt; &lt;数据类型&gt;[完整性约束]]</span><br><span class="line">[ADD &lt;表级完整性约束&gt;]  -- FOREIGN KEY (Sno) REFERENCES &lt;表名&gt;(列名)</span><br><span class="line">[DROP [COLMUN] &lt;列名&gt; [CASCADE|RESTRICT]]</span><br><span class="line">[DROP CONSTRAINT &lt;完整性约束名&gt;[CASCADE|RESTRICT]]</span><br><span class="line">[ALTER COLUMN &lt;列名&gt;&lt;数据类型&gt;];</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">alter table student modify Ssex char(2);  -- 修改属性的数据类型</span><br><span class="line">update course set Cpno=NULL where Cno=2;  -- 修改数据的值</span><br><span class="line">alter table Student add S_entrance DATE;  -- 添加一行S_entrance</span><br><span class="line">alter table Course add UNIQUE(Cname);  -- 增加课程名必须取唯一值的约束</span><br></pre></td></tr></table></figure>

<h5 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP TABLE &lt;表名&gt; [CASCADE|RESTRICT(默认)];  -- CASCADE相关的依赖都被删掉，如视图；RESTRICT有依赖则不可以</span><br></pre></td></tr></table></figure>

<h4 id="索引的建立与删除（内模式的范畴）"><a href="#索引的建立与删除（内模式的范畴）" class="headerlink" title="索引的建立与删除（内模式的范畴）"></a>索引的建立与删除（内模式的范畴）</h4><ul>
<li>顺序索引</li>
<li>B+树索引</li>
<li>Hash索引</li>
<li>位图索引</li>
</ul>
<h5 id="建立索引"><a href="#建立索引" class="headerlink" title="建立索引"></a>建立索引</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">create unique index Stusno on Student(Sno);</span><br><span class="line">create unique index SCno on SC(Sno ASC, Cno DESC);  -- ASC升序；DESC降序</span><br></pre></td></tr></table></figure>

<h5 id="修改索引"><a href="#修改索引" class="headerlink" title="修改索引"></a>修改索引</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter index SCno rename to SCSno;  -- 8.0不可用</span><br></pre></td></tr></table></figure>

<h5 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE SC drop index SCno;</span><br></pre></td></tr></table></figure>

<h3 id="数据查询"><a href="#数据查询" class="headerlink" title="数据查询"></a>数据查询</h3><ul>
<li><strong>需要注意的点：</strong><ul>
<li>聚集函数。只能用于Select子句和group by 中的having子句</li>
<li>where子句不能用聚集函数作为条件表达式</li>
<li>子查询的selcet语句中不能使用order by子句，order by只能用于最后的语句</li>
<li>集合查询的各个查询结果需要列数相同；对应项的数据类型也必须相同</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select [all|distinct] &lt;目标列表达式&gt;[,&lt;目标列表达式&gt;]...</span><br><span class="line">from &lt;表名或视图名&gt;[,&lt;表名或视图名&gt;...] | (select语句) [as] &lt;别名&gt;</span><br><span class="line">[where &lt;条件表达式&gt;]</span><br><span class="line">[group by &lt;列名1&gt; [having&lt;条件表达式&gt;]]</span><br><span class="line">[order by &lt;列名2&gt; [ASC|DESC]]</span><br></pre></td></tr></table></figure>



<h4 id="单表查询"><a href="#单表查询" class="headerlink" title="单表查询"></a>单表查询</h4><h5 id="查找列"><a href="#查找列" class="headerlink" title="查找列"></a>查找列</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">select Sno,Sname from Student;</span><br><span class="line"></span><br><span class="line">select Sname,Sno,Sdept from Student;  -- 可以不按照定义基本表时候的顺序</span><br><span class="line"></span><br><span class="line">select Sname, 2014-Sage from Student;</span><br><span class="line">/*</span><br><span class="line">+-------+-----------+</span><br><span class="line">| Sname | 2014-Sage |</span><br><span class="line">+-------+-----------+</span><br><span class="line">| 李勇  |      1994 |</span><br><span class="line">| 刘晨  |      1995 |</span><br><span class="line">| 王敏  |      1996 |</span><br><span class="line">| 张立  |      1995 |</span><br><span class="line">+-------+-----------+</span><br><span class="line">4 rows in set (0.08 sec)</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">select Sname,&#x27;Year of birth:&#x27;,2014-Sage, Lower(Sdept) from Student;  -- 查询全体学生的姓名、出生年份、所在院系（小写字母表示）</span><br><span class="line">/*</span><br><span class="line">+-------+----------------+-----------+--------------+</span><br><span class="line">| Sname | Year of birth: | 2014-Sage | Lower(Sdept) |</span><br><span class="line">+-------+----------------+-----------+--------------+</span><br><span class="line">| 李勇  | Year of birth: |      1994 | cs           |</span><br><span class="line">| 刘晨  | Year of birth: |      1995 | cs           |</span><br><span class="line">| 王敏  | Year of birth: |      1996 | ma           |</span><br><span class="line">| 张立  | Year of birth: |      1995 | is           |</span><br><span class="line">+-------+----------------+-----------+--------------+</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">select Sname NAME,&#x27;Year of birth:&#x27;BIRTH, 2014-Sage BIRTHDAY, LOWER(Sdept) DEPARTMENT from Student;</span><br><span class="line">/*</span><br><span class="line">+------+----------------+----------+------------+</span><br><span class="line">| NAME | BIRTH          | BIRTHDAY | DEPARTMENT |</span><br><span class="line">+------+----------------+----------+------------+</span><br><span class="line">| 李勇 | Year of birth: |     1994 | cs         |</span><br><span class="line">| 刘晨 | Year of birth: |     1995 | cs         |</span><br><span class="line">| 王敏 | Year of birth: |     1996 | ma         |</span><br><span class="line">| 张立 | Year of birth: |     1995 | is         |</span><br><span class="line">+------+----------------+----------+------------+</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<h5 id="查找行（元组）"><a href="#查找行（元组）" class="headerlink" title="查找行（元组）"></a>查找行（元组）</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">-- 1.消除取值重复的行</span><br><span class="line">select distinct Sno from SC;  -- 取消重复的行，如果没有，则会出现重读的行</span><br><span class="line">/*</span><br><span class="line">+-----------+</span><br><span class="line">| Sno       |</span><br><span class="line">+-----------+</span><br><span class="line">| 201215121 |</span><br><span class="line">| 201215122 |</span><br><span class="line">+-----------+</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">-- 2.查询满足条件的元组</span><br><span class="line">-- 2.1 比较大小=,&gt;,&lt;,&gt;=,&lt;=,!=/&lt;&gt;,!&gt;,!&lt;</span><br><span class="line">select Sname from Student where Sdept=&#x27;CS&#x27;;</span><br><span class="line">/*</span><br><span class="line">+-------+</span><br><span class="line">| Sname |</span><br><span class="line">+-------+</span><br><span class="line">| 李勇  |</span><br><span class="line">| 刘晨  |</span><br><span class="line">+-------+</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">select distinct Sno from SC where Grade&lt;60;  -- 去除重复学号</span><br><span class="line">-- 2.2 确定范围</span><br><span class="line">select Sname,Sdept,Sage from Student where Sage between 20 and 23;  -- 20~23之间的人</span><br><span class="line">select Sname,Sdept,Sage from Student where Sage not between 20 and 23;</span><br><span class="line">-- 2.3 确定集合</span><br><span class="line">select Sname,Ssex from Student where Sdept in (&#x27;CS&#x27;,&#x27;MA&#x27;);</span><br><span class="line">-- 2.4 字符匹配 通配符%(任意长度字符串)；_(单个字符)</span><br><span class="line">select * from Student where Sno like &#x27;2015%&#x27;;</span><br><span class="line">select Sname,Sno from Student where Sname like &#x27;_勇%&#x27;;  -- 查找名字第二个字带勇</span><br><span class="line">select Cno,Ccredit from Course where Cname like &#x27;DB\_Design&#x27;;  -- mySQL8.0中已经不需要在最后加上ESCAPE&#x27;\&#x27;，甚至都不需要转义符，直接select Cno,Ccredit,Cname from Course where Cname like &#x27;DB_Design&#x27;;</span><br><span class="line">select * from Course where Cname like &#x27;DB\_%i%&#x27;;</span><br><span class="line"></span><br><span class="line">-- 2.5 涉及空值的查询</span><br><span class="line">select Sno,Cno from SC Where Grade is null;  -- is 不可以用空值表示</span><br><span class="line"></span><br><span class="line">-- 2.6 多重条件查询</span><br><span class="line">select Sname from Student where Sdept=&#x27;CS&#x27; and Sage&lt;20;</span><br><span class="line"></span><br><span class="line">-- 3 order by 子句</span><br><span class="line">select * from SC where Cno=&#x27;3&#x27; order by grade DESC; </span><br><span class="line">/*</span><br><span class="line">+-----------+-----+-------+</span><br><span class="line">| Sno       | Cno | Grade |</span><br><span class="line">+-----------+-----+-------+</span><br><span class="line">| 201215121 | 3   |    88 |</span><br><span class="line">| 201215122 | 3   |    80 |</span><br><span class="line">+-----------+-----+-------+</span><br><span class="line">*/</span><br><span class="line">select * from Student order by Sdept,Sage DESC;  -- 按照所在的系号升序排序，同一个系的年龄降序</span><br><span class="line">/*</span><br><span class="line">+-----------+-------+------+------+-------+</span><br><span class="line">| Sno       | Sname | Ssex | Sage | Sdept |</span><br><span class="line">+-----------+-------+------+------+-------+</span><br><span class="line">| 201215121 | 李勇  | 男   |   20 | CS    |</span><br><span class="line">| 201215122 | 刘晨  | 女   |   19 | CS    |</span><br><span class="line">| 201215125 | 张立  | 男   |   19 | IS    |</span><br><span class="line">| 201215123 | 王敏  | 女   |   18 | MA    |</span><br><span class="line">+-----------+-------+------+------+-------+</span><br><span class="line">*/</span><br><span class="line">-- 4 聚集函数。只能用于Select子句和group by 中的having子句</span><br><span class="line">/*</span><br><span class="line">COUNT(*)</span><br><span class="line">count([distinct|all] &lt;列名&gt;)</span><br><span class="line">sum([distinct|all] &lt;列名&gt;)</span><br><span class="line">avg([distinct|all] &lt;列名&gt;)</span><br><span class="line">max([distinct|all] &lt;列名&gt;)</span><br><span class="line">min([distinct|all] &lt;列名&gt;)</span><br><span class="line">*/</span><br><span class="line">select count(*) from Student;  -- 查询学生总人数/表的行数</span><br><span class="line">select count(distinct Sno) from SC; -- 查询选修了课程的总人数</span><br><span class="line">select avg(Grade) from SC where Cno=&#x27;1&#x27;;  -- 算课程号为1的平均分</span><br><span class="line">select max(Grade) from SC where Cno=&#x27;1&#x27;;   -- 最高分</span><br><span class="line">select sum(Ccredit) from SC,Course where Sno=&#x27;201215121&#x27; and SC.Cno=Course.Cno;  -- 查询该学号学生选修课程的总的学分数</span><br><span class="line"></span><br><span class="line">-- 5 group by 子句</span><br><span class="line">select Cno,Count(Sno) from SC group by Cno;  -- 查询各个课程号及其相应的选课人数</span><br><span class="line">/*</span><br><span class="line">+-----+------------+</span><br><span class="line">| Cno | Count(Sno) |</span><br><span class="line">+-----+------------+</span><br><span class="line">| 1   |          1 |</span><br><span class="line">| 2   |          2 |</span><br><span class="line">| 3   |          2 |</span><br><span class="line">+-----+------------+</span><br><span class="line">*/</span><br><span class="line">---- 分组后再进行筛选，可以having指定</span><br><span class="line">select Sno from SC group by Sno Having Count(*)&gt;3;</span><br><span class="line"></span><br><span class="line">---- where子句不能用聚集函数作为条件表达式</span><br><span class="line">select Sno,avg(Grade) from SC group by Sno having avg(grade)&gt;=80;</span><br><span class="line">-- 这个运行不出来</span><br><span class="line">-- select Sno,avg(Grade) from SC where avg(grade)&gt;=80 group by Sno;</span><br></pre></td></tr></table></figure>



<h4 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h4><p>涉及两个表以上的查询，包括：</p>
<ol>
<li><p>等值连接查询</p>
<ul>
<li>```<br>– where子句的形式：[&lt;表名1&gt;.]&lt;列名2&gt;&lt;比较运算符&gt;[&lt;表名2&gt;.]&lt;列名2&gt;<br>– 或者是[&lt;表名1&gt;.]&lt;列名2&gt;&lt;比较运算符&gt;between[&lt;表名2&gt;.]&lt;列名2&gt;and[&lt;表名2&gt;.]&lt;列名3&gt;<br>select Student.<em>,SC.</em> from Student,SC where Student.Sno=SC.Sno;<br>/*<br>+———–+——–+——+——+——-+———–+—–+——-+<br>| Sno       | Sname  | Ssex | Sage | Sdept | Sno       | Cno | Grade |<br>+———–+——–+——+——+——-+———–+—–+——-+<br>| 201215121 | 李勇   | 男   |   20 | CS    | 201215121 | 1   |    92 |<br>| 201215121 | 李勇   | 男   |   20 | CS    | 201215121 | 2   |    85 |<br>| 201215121 | 李勇   | 男   |   20 | CS    | 201215121 | 3   |    88 |<br>| 201215122 | 刘晨   | 女   |   19 | CS    | 201215122 | 2   |    90 |<br>| 201215122 | 刘晨   | 女   |   19 | CS    | 201215122 | 3   |    80 |<br>+———–+——–+——+——+——-+———–+—–+——-+<br>*/<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">2. 自然连接查询</span><br><span class="line"></span><br><span class="line">   - ```</span><br><span class="line">     select Student.Sno,Sname,Ssex,Sage,Sdept,Cno,Grade from Student,SC where Student.Sno=SC.Sno;</span><br><span class="line">     /*</span><br><span class="line">     +-----------+--------+------+------+-------+-----+-------+</span><br><span class="line">     | Sno       | Sname  | Ssex | Sage | Sdept | Cno | Grade |</span><br><span class="line">     +-----------+--------+------+------+-------+-----+-------+</span><br><span class="line">     | 201215121 | 李勇   | 男   |   20 | CS    | 1   |    92 |</span><br><span class="line">     | 201215121 | 李勇   | 男   |   20 | CS    | 2   |    85 |</span><br><span class="line">     | 201215121 | 李勇   | 男   |   20 | CS    | 3   |    88 |</span><br><span class="line">     | 201215122 | 刘晨   | 女   |   19 | CS    | 2   |    90 |</span><br><span class="line">     | 201215122 | 刘晨   | 女   |   19 | CS    | 3   |    80 |</span><br><span class="line">     +-----------+--------+------+------+-------+-----+-------+</span><br><span class="line">     */</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>非等值连接查询</p>
<ul>
<li>```<br>select Student.Sno,Sname from Student,SC where Student.Sno=SC.Sno and SC.Cno=’2’ and SC.Grade&gt;=90;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">4. 自身连接查询</span><br><span class="line"></span><br><span class="line">   - ```</span><br><span class="line">     Select first.Cno,second.Cpno from Course first,Course second where first.Cpno=second.Cno;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>外连接查询</p>
<ul>
<li>```<br>select Student.Sno,Sname,Ssex,Sage,Sdept,Cno,Grade from Student left outer join SC on (Student.Sno=SC.Sno);<br>/*<br>+———–+——–+——+——+——-+——+——-+<br>| Sno       | Sname  | Ssex | Sage | Sdept | Cno  | Grade |<br>+———–+——–+——+——+——-+——+——-+<br>| 201215121 | 李勇   | 男   |   20 | CS    | 3    |    88 |<br>| 201215121 | 李勇   | 男   |   20 | CS    | 2    |    85 |<br>| 201215121 | 李勇   | 男   |   20 | CS    | 1    |    92 |<br>| 201215122 | 刘晨   | 女   |   19 | CS    | 3    |    80 |<br>| 201215122 | 刘晨   | 女   |   19 | CS    | 2    |    90 |<br>| 201215123 | 王敏   | 女   |   18 | MA    | NULL |  NULL |<br>| 201215125 | 张立   | 男   |   19 | IS    | NULL |  NULL |<br>+———–+——–+——+——+——-+——+——-+<br>*/<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">6. 复合条件查询/多表查询</span><br><span class="line"></span><br><span class="line">   - ```</span><br><span class="line">     select Student.Sno,Sname,Cname,Grade from Student,SC,Course where Student.Sno=SC.Sno and SC.Cno=Course.Cno;</span><br><span class="line">     /*</span><br><span class="line">     +-----------+--------+--------------+-------+</span><br><span class="line">     | Sno       | Sname  | Cname        | Grade |</span><br><span class="line">     +-----------+--------+--------------+-------+</span><br><span class="line">     | 201215121 | 李勇   | 数据库       |    92 |</span><br><span class="line">     | 201215121 | 李勇   | 数学         |    85 |</span><br><span class="line">     | 201215121 | 李勇   | 信息系统     |    88 |</span><br><span class="line">     | 201215122 | 刘晨   | 数学         |    90 |</span><br><span class="line">     | 201215122 | 刘晨   | 信息系统     |    80 |</span><br><span class="line">     +-----------+--------+--------------+-------+</span><br><span class="line">     */</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h4 id="嵌套查询（in-比较-any-all-exists）"><a href="#嵌套查询（in-比较-any-all-exists）" class="headerlink" title="嵌套查询（in,比较,any/all,exists）"></a>嵌套查询（in,比较,any/all,exists）</h4><ul>
<li><p>带有in谓词的查询</p>
<ul>
<li><p><strong>注意：子查询的selcet语句中不能使用order by子句，order by只能用于最后的语句</strong></p>
</li>
<li><p>```<br>SELECT</p>
<pre><code>Sname 
</code></pre>
<p>FROM</p>
<pre><code>Student 
</code></pre>
<p>WHERE</p>
<pre><code>Sno IN ( SELECT Sno FROM SC WHERE Cno = &#39;2&#39; );
</code></pre>
<p>– 查询和刘晨一个系的人的信息<br>SELECT</p>
<pre><code>Student.*
</code></pre>
<p>FROM</p>
<pre><code>Student 
</code></pre>
<p>WHERE</p>
<pre><code>Sdept IN ( SELECT Sdept FROM Student WHERE Sname = &#39;刘晨&#39; );
</code></pre>
<p>– 也可以采用外连接的方式<br>select S1.* from Student S1, Student S2 where S1.Sdept=S2.Sdept and S2.Sname=’刘晨’<br>/*<br>李勇    男    20    CS<br>刘晨    女    19    CS<br>*/</p>
<p>– 查询选修了“信息系统”的学生的姓名学号<br>SELECT Student.Sname, Student.Sno from Student where Sno IN<br>(SELECT Sno FROM SC WHERE Cno IN<br> (SELECT Cno from Course  WHERE Cname=’信息系统’))；<br> – 方法2<br>SELECT *<br>from Student,Course,SC WHERE Course.Cno=SC.Cno AND SC.Sno=Student.Sno AND Course.Cname=’信息系统’</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">- 带有比较运算符的查询</span><br><span class="line"></span><br><span class="line">  - ```</span><br><span class="line">    -- 找出每个学生超过他选修课平均成绩的课程号</span><br><span class="line">    SELECT *</span><br><span class="line">    FROM SC,(SELECT SC.Sno,AVG(SC.Grade) avg FROM SC GROUP BY Sno) AS S1</span><br><span class="line">    WHERE SC.Sno=S1.Sno AND SC.Grade&gt;S1.avg;</span><br><span class="line">    </span><br><span class="line">    SELECT Sno,Cno from SC x WHERE Grade &gt;=(SELECT AVG(Grade) from SC y WHERE y.Sno=x.Sno);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>带有any(some)或者all谓词的查询</p>
<ul>
<li>```<br>– 查询非CS系比CS系任意一个学生年龄小的学生姓名和年龄<br>SELECT<pre><code>Sname,
Sage 
</code></pre>
FROM<pre><code>Student 
</code></pre>
WHERE<pre><code>Student.Sage &lt; ANY ( SELECT Sage FROM Student WHERE Sdept = &#39;CS&#39; ) 
AND Student.Sdept &lt;&gt; &#39;CS&#39;
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 带有exists谓词的子查询</span><br><span class="line"></span><br><span class="line">  - exist谓词的子句查询不反悔任何数据，只产生逻辑真假</span><br><span class="line"></span><br><span class="line">  - ```</span><br><span class="line">    -- 查询所有选修了1号课程的学生姓名</span><br><span class="line">    SELECT Sname,Sno</span><br><span class="line">    FROM Student</span><br><span class="line">    WHERE EXISTS (SELECT * FROM SC,Student where SC.Sno=Student.Sno and Cno=&#x27;1&#x27;);</span><br><span class="line">    </span><br><span class="line">    -- 查询至少选修了学生201215122选的全部课程的学生号码</span><br><span class="line">    SELECT DISTINCT</span><br><span class="line">    	Sno</span><br><span class="line">    FROM</span><br><span class="line">    	SC SCX </span><br><span class="line">    WHERE</span><br><span class="line">    	NOT EXISTS (</span><br><span class="line">    	SELECT</span><br><span class="line">    		* </span><br><span class="line">    	FROM</span><br><span class="line">    		SC SCY </span><br><span class="line">    	WHERE</span><br><span class="line">    	SCY.Sno = &#x27;201215122&#x27; </span><br><span class="line">    	AND NOT EXISTS ( SELECT * FROM SC SCZ WHERE SCZ.Sno = SCX.Sno AND SCZ.Cno = SCY.Cno ))</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="集合查询（并-UNION-交-INTERSECT-差-EXCEPT-）"><a href="#集合查询（并-UNION-交-INTERSECT-差-EXCEPT-）" class="headerlink" title="集合查询（并(UNION)交(INTERSECT)差(EXCEPT)）"></a>集合查询（并(UNION)交(INTERSECT)差(EXCEPT)）</h4><ul>
<li><p>```<br>– 查询CS系里的学生及年龄不大于19岁的学生<br>SELECT</p>
<pre><code>* 
</code></pre>
<p>FROM</p>
<pre><code>Student 
</code></pre>
<p>WHERE</p>
<pre><code>Sdept = &#39;CS&#39; UNION
</code></pre>
<p>SELECT</p>
<pre><code>* 
</code></pre>
<p>FROM</p>
<pre><code>Student 
</code></pre>
<p>WHERE</p>
<pre><code>Sage &lt;= 19;
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 基于派生表的查询</span><br><span class="line"></span><br><span class="line">子查询不仅可以出现在WHERE子句中，还可以出现在FROM子句里面，这时候子查询生成的临时派生表成为主查询的查询对象。</span><br><span class="line"></span><br><span class="line">**FROM子句里面的派生表必须要有别名。**</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><ul>
<li>选择每个学生超过他自己平均成绩的课程的课程号<br>SELECT<br> Sno,<br> Cno<br>FROM<br> SC,<br> ( SELECT Sno, Avg( Grade ) FROM SC GROUP BY Sno ) AS Avg_sc ( avg_sno, avg_grade )<br>WHERE<br> SC.Sno = Avg_sc.avg_sno<br> AND SC.Grade &gt;= Avg_sc.avg_grade<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 数据更新</span><br><span class="line"></span><br><span class="line">#### 插入数据</span><br><span class="line"></span><br><span class="line">- 插入元组</span><br><span class="line"></span><br><span class="line">  - ```</span><br><span class="line">    INSERT INTO Student (Sno, Sname, Sage, Sdept, Ssex)</span><br><span class="line">    VALUES(&#x27;201951001&#x27;, &#x27;张三&#x27;, 18, &#x27;CS&#x27;, &#x27;男&#x27;)</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
<li><p>插入子查询的结果</p>
<ul>
<li>```<br>– CREATE TABLE Dept_age (Sdept CHAR(15),Avg_age SMALLINT)<br>INSERT INTO Dept_age(Sdept, Avg_age)<br>SELECT Sdept, AVG(Sage) FROM Student GROUP BY Sdept;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">#### 修改数据</span><br><span class="line"></span><br><span class="line">- 修改某一个元组的值</span><br><span class="line"></span><br><span class="line">  - ```</span><br><span class="line">    -- 修改数据</span><br><span class="line">    UPDATE Student SET Sage=22 WHERE Sno=&#x27;201215121&#x27;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>修改多个元组的值</p>
<ul>
<li>```<br>– 修改多个元组的值<br>– UPDATE Student SET Sage=Sage+1<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 带子查询的修改</span><br><span class="line"></span><br><span class="line">  - ```</span><br><span class="line">    -- 带子查询的修改语句:CS系的学生成绩设置成0</span><br><span class="line">    UPDATE SC SET Grade=0 WHERE Sno IN(SELECT Sno FROM Student WHERE Sdept=&#x27;CS&#x27;)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-- 删除一个元组</span><br><span class="line">DELETE FROM Student WHERE Sno=&#x27;201215128&#x27;</span><br><span class="line">-- 删除多个元组</span><br><span class="line">DELETE FROM SC</span><br><span class="line">-- 带有子查询的删除</span><br><span class="line">DELETE FROM SC WHERE Sno IN (SELECT Sno FROM Student WHERE Sdept=&#x27;DD&#x27;)</span><br></pre></td></tr></table></figure>

<h3 id="空值处理"><a href="#空值处理" class="headerlink" title="空值处理"></a>空值处理</h3><p>空值：不知道、不存在、无意义的值</p>
<ul>
<li><p>产生：    </p>
<ul>
<li>插入、修改</li>
</ul>
</li>
<li><p>判断：</p>
<ul>
<li><p>IS NULL </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM Student WHERE Sname IS NULL OR Sage IS NULL OR Sdept IS NULL</span><br></pre></td></tr></table></figure></li>
<li><p>IN NOT NULL</p>
</li>
</ul>
</li>
<li><p>空值与空值的算术运算为空，比较运算为UNKNOW    </p>
</li>
</ul>
<h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><p>视图从一个或几个基本表（或视图）导出的表。</p>
<p>数据库只存放视图的定义，不存放视图对应的数据，基本表变化，那么视图也跟着变化了。</p>
<h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p><strong>组成视图的属性列名要么全部省略要么全部指定。</strong></p>
<p><strong>行列子视图</strong>：从单个基本表导出，只是去掉了基本的行或者列，但是保留了主码</p>
<ul>
<li>三种必须指定列名的情况：<ol>
<li>某个目标列不是属性名，而是聚集函数或者列表达式</li>
<li>多表连接选择了同名列</li>
<li>需要在视图里面为某个列启用新的更合适的名字</li>
</ol>
</li>
<li>创建视图</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">-- WITH CHECK OPTION表示对视图进行插入删除修改的时候，会自动加上Sdept=&#x27;IS&#x27;条件</span><br><span class="line">-- 建立在单个表的视图</span><br><span class="line">CREATE VIEW IS_Student AS SELECT Sno,Sname,Sage FROM Student WHERE Sdept=&#x27;IS&#x27; WITH CHECK OPTION</span><br><span class="line">-- 建立在多个基本表的视图:建立选修了1号课程的学生的视图</span><br><span class="line">CREATE VIEW IS_S1(Sno, Sname, Grade)AS SELECT Student.Sno, Sname, Grade FROM Student, SC WHERE Sdept=&#x27;IS&#x27; AND Student.Sno=SC.Sno AND SC.Cno=&#x27;1&#x27;</span><br><span class="line">-- 建立在视图上的视图</span><br><span class="line">CREATE VIEW IS_S2 as SELECT Sno,Sname,Grade FROM IS_S1 WHERE Grade&gt;=90</span><br><span class="line">-- 带有表达式的视图：存在虚拟列</span><br><span class="line">CREATE VIEW BT_S(Sno, Sname, Sbirth) as SELECT Sno, Sname, 2014-Sage FROM Student</span><br><span class="line">-- 分组视图：用带有聚集函数和GROUP BY子句的查询定义的</span><br><span class="line">CREATE VIEW S_G(Sno, Gavg) AS SELECT Sno, AVG(Grade) FROM SC GROUP BY Sno</span><br></pre></td></tr></table></figure>

<ul>
<li>删除视图</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP VIEW BT_S CASCADE -- 级联删除</span><br></pre></td></tr></table></figure>

<h4 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h4><p><strong>视图消解：</strong>DBMS在进行对视图的查询的时候：</p>
<ul>
<li>首先进行有效性检查，检查中查询中涉及的表或者视图是否存在；</li>
<li>如果存在：<ul>
<li>从数据字典中取出视图的定义，把定义中的子查询和用户的查询结合起来，转换成等价的对基本表的查询，然后就执行修正的查询。</li>
</ul>
</li>
</ul>
<p><strong>注意：</strong>如果视图是由聚集函数生成的视图，那么查询不能运行。因为where子句不能由聚集函数。</p>
<p>也就是DBMS对行列子视图的查询基本都能正确转换。</p>
<h4 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h4><p>视图消解之后转换成对基本表的更新。</p>
<p>基本表的更新也不是都能成，一般来说对于行列子视图的都能成功。对于聚集函数生成的就不行。</p>
<h4 id="视图的作用"><a href="#视图的作用" class="headerlink" title="视图的作用"></a>视图的作用</h4><ul>
<li>简化操作</li>
<li>用户能够以多个角度看待同一数据</li>
<li>对重构数据库提供一定程度的逻辑独立性</li>
<li>保护机密数据</li>
<li>更清晰的表达查询</li>
</ul>
<h2 id="数据库安全性"><a href="#数据库安全性" class="headerlink" title="数据库安全性"></a>数据库安全性</h2><h3 id="安全性概述"><a href="#安全性概述" class="headerlink" title="安全性概述"></a>安全性概述</h3><p>保护数据库以防止不合法使用造成的数据泄露、更改、破坏。</p>
<ol>
<li>数据库的不安全因素<ol>
<li>非授权用户对数据库的恶意存取和破坏</li>
<li>数据库中重要或敏感信息的泄露</li>
<li>安全环境的脆弱性</li>
</ol>
</li>
<li>数据库安全标准<ol>
<li>TCSEC</li>
<li>安全级别的划分<ol>
<li>D级：最小保护</li>
<li>C1：初级自主安全保护，无用户、数据的分离，进行自主存取控制（DAC，用户对不同的数据库对象具有不同的存取权限，不同用户对同一对象存取权限也不一样，用户权限可以转授），保护或者限制用户权限的传播</li>
<li>C2：安全产品的最低档，提供受控的存取保护，以个人身份注册负责，实施审计与资源隔离。如windows2000， oracle7</li>
<li>B1：标记安全保护。对数据加以标记，对标记的主体、客体实施强制存取控制（MAC，数据库对象有一定的密级，每个用户有对某一级别的许可证。）以及审计等安全机制。真正意义的安全产品。</li>
<li>B2：结构化保护。建立形式化的安全策略模型，并对系统内所有主体和客体实施DAC、MAC。</li>
<li>B3：安全域。TCB（Trusted Computing Base）必须满足访问监控器的要求，审计跟踪能力更强，并提供系统恢复过程。</li>
<li>A1：验证设计。给出系统的形式化设计说明和验证，以确保各安全保护真正实现。</li>
</ol>
</li>
<li>CC(已经采用为国家标准)。等级：EAL1~2==C1~C2，后边的依次对应</li>
</ol>
</li>
</ol>
<h3 id="安全性控制"><a href="#安全性控制" class="headerlink" title="安全性控制"></a>安全性控制</h3><ol>
<li><p>用户身份控制</p>
<ol>
<li>用户标识由用户名和用户标识号（UID）构成，</li>
<li>身份鉴别方法：静态口令、动态口令、生物特征、智能卡</li>
</ol>
</li>
<li><p>存取控制</p>
<ol>
<li>用户权限检查</li>
<li>合法权限检查</li>
<li>以上两者构成DBMS的存取控制子系统。</li>
</ol>
</li>
<li><p>自主存取控制方法</p>
<ul>
<li><img src="/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/0%E6%95%B0%E6%8D%AE%E5%BA%93/image-20210825222715715.png" alt="image-20210825222715715"></li>
</ul>
</li>
<li><p>授权：授权与回收</p>
<ol>
<li><p>GRANT</p>
<ul>
<li>```<br>GRANT SELECT ON TABLE Student TO LIXIAN – 将查询权限授权给用户<br>GRANT all privileges ON TABLE Student TO LIXIAN,user1<br>GRANT SELECT ON TABLE Student TO PUBLIC – 谁都行<br>GRANT SELECT ON TABLE Student TO PUBLIC WITH GRANT OPTION – 允许权限再授权<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">2. REVOKE</span><br><span class="line"></span><br><span class="line">   - ```</span><br><span class="line">     REVOKE SELECT ON TABLE SC FROM PUBLIC</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>创建数据库模式的权限</p>
<ul>
<li><img src="/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/0%E6%95%B0%E6%8D%AE%E5%BA%93/image-20210825223248415.png" alt="image-20210825223248415" style="zoom:50%;"></li>
<li><p>```<br>CREATE USER <username> [WITH][DBA|RESOURCE|CONNECT]</username></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">5. 数据库角色（其实就是用户组）</span><br><span class="line"></span><br><span class="line">   1. 数据库角色是被命名的一组与数据库操作相关的权限，角色是权限的集合。一组具有相同权限的用户创建一个角色</span><br><span class="line"></span><br><span class="line">   2. 角色操作</span><br><span class="line"></span><br><span class="line">      1. 创建：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p> CREATE USER &lt;角色名&gt;</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. 授权同用户的授权</span><br><span class="line"></span><br><span class="line">3. 角色授予用户</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p> GRANT &lt;角色1,2,3&gt; TO &lt;角色n&gt;[&lt;用户1&gt;] WITH ADMIN OPTION  – 可以继续再授权 </p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">4. 回收</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p> REVOKE &lt;权限&gt; ON &lt;对象类型&gt; FROM &lt;角色&gt;</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">         </span><br><span class="line"></span><br><span class="line">6. 强制存取控制方法</span><br><span class="line"></span><br><span class="line">   1. 系统中的活动实体，分为主体和客体。主体包括用户、用户的各个进程；客体包括文本、基本表、索引、视图。</span><br><span class="line">   2. 数据库对主体和客体分配**敏感度标记**，主体的敏感度标记称为许可证级别，客体的称为密级。</span><br><span class="line"></span><br><span class="line">### 视图机制</span><br><span class="line"></span><br><span class="line">1. 建立一个视图，在视图上定义用户的权限，</span><br><span class="line"></span><br><span class="line">### 审计</span><br><span class="line"></span><br><span class="line">对服务器事件、系统权限、SQL语句事件、模式对象事件（对特定模式对象\&lt;表、视图、存储过程、函数\&gt;上进行的SELECT或者DML操作）</span><br><span class="line"></span><br><span class="line">用AUIDIT NOTAUDIT开启、关闭审计功能。</span><br><span class="line"></span><br><span class="line">### 数据加密</span><br><span class="line"></span><br><span class="line">1. 存储加密</span><br><span class="line">2. 传输加密</span><br><span class="line"></span><br><span class="line">### 其它安全性保护</span><br><span class="line"></span><br><span class="line">1. 推理控制（由函数依赖关系推断出高等级信息）</span><br><span class="line">2. 隐蔽信道</span><br><span class="line"></span><br><span class="line">## 数据库完整性（数据库核心支持的功能）</span><br><span class="line"></span><br><span class="line">指的是数据的正确性（correctness，数据符合现实，反映现实）和相容性（compat-ability，数据库同一对象在不同关系表中的数据是符合逻辑的）。</span><br><span class="line"></span><br><span class="line">要求DBMS：提供定义完整性约束条件的机制；提供完整性检查的方法；进行违约处理。</span><br><span class="line"></span><br><span class="line">### 实体完整性</span><br><span class="line"></span><br><span class="line">1. 定义：在CREATE TABLE中用PRIMARY KEY定义。</span><br><span class="line">   - 对单属性构成的码</span><br><span class="line">     - 定义为列级约束条件，例如`(Sno CHAR(9) PRIMARY KEY, ...);`</span><br><span class="line">     - 定义为表级约束条件，例如`(Sno CHAR(9), ..., PRIMARY KEY(Sno));`</span><br><span class="line">   - 对多属性构成的码：</span><br><span class="line">     - 只能定义为表级约束条件，例如`(Sno CHAR(9), ..., PRIMARY KEY(Sno, Cno));`</span><br><span class="line">2. 实体完整性检查和违约处理</span><br><span class="line">   1. 检查是否唯一。一般建立一个B+树的索引，减少耗时</span><br><span class="line">   2. 检查是否为空</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 参照完整性</span><br><span class="line"></span><br><span class="line">1. 定义：用FOREIGN KEY定义外码，用REFERENCE指明外码参照哪些表的主码</span><br><span class="line">   - `(..., PRIMARY KEY (Sno,Cno), FOREIGN KEY (Sno) REFERENCES Student(Sno), FOREIGN KEY (Cno) REFERENCES Course(Cno) )`</span><br><span class="line">2. 参照完整性检查和违约处理</span><br><span class="line">   - &lt;img src=&quot;0数据库/image-20210826001946233.png&quot; alt=&quot;image-20210826001946233&quot; style=&quot;zoom:67%;&quot; /&gt;</span><br><span class="line">   - 处理策略</span><br><span class="line">     - 拒绝</span><br><span class="line">     - 级联：当删除或修改被参照表的一个元组导致与参照表的不一致时，删除或修改参照表中所有导致不一致的元组。</span><br><span class="line">     - 置空</span><br><span class="line"></span><br><span class="line">### 用户定义的完整性</span><br><span class="line"></span><br><span class="line">1. 属性上的约束</span><br><span class="line">   1. NOT NULL，不允许为空值</span><br><span class="line">   2. UNIQUE，列值唯一</span><br><span class="line">   3. CHECK， 指定列满足的条件，例如`Ssex CHAR(2) CHECK(sSEX IN (&#x27;男&#x27;，&#x27;女&#x27;))`</span><br><span class="line">2. 元组上的约束</span><br><span class="line">   1. 在定义完所有属性的类型之后统一集中定义</span><br><span class="line"></span><br><span class="line">### 完整性约束命名子句(CONSTRAINT)</span><br><span class="line"></span><br><span class="line">1. 完整性约束命名子句</span><br><span class="line"></span><br><span class="line">   - ```</span><br><span class="line">     CREATE TABLE Student (Sno NUMERIC(6) CONSTRAINT C1 CHECK(Sno between 90000 AND 99999),..., CONSTRAINT StudentKey PRIMARY KEY(Sno))</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
</li>
<li><p>修改表中的完整性限制</p>
<ul>
<li>```<br>ALTER TABLE Student DROP CONTRSTRAINT C1<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   - 修改：先删除再新增</span><br><span class="line"></span><br><span class="line">### 域中的完整性限制(DOMAIN)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
CREATE DOMAIN GenderDomain CHAR(2) CHECK (VALUE IN (‘男’,’女’))</li>
</ul>
</li>
</ol>
<p>– 那么新建表的时候，可以 Ssex GenderDoamin<br>– 可以结合CONSTRAINT</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 断言(ASSERTION)</span><br><span class="line"></span><br><span class="line">1. 定义</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>CREATE ASSERTION ASSE_SC_DB_NUM<br>CHECK (60 &gt;= (SELECT COUNT(*) FROM Course, SC WHERE SC.Cno=Course.Cname=’数据库’))<br>– 限制数据库最多60个人选修</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 删除`DROP ASSERTION &lt;断言名&gt;`</span><br><span class="line"></span><br><span class="line">### 触发器（TRIGGER）</span><br><span class="line"></span><br><span class="line">1. 定义：</span><br><span class="line"></span><br><span class="line">   1. ```</span><br><span class="line">      CREATE TRIGGER &lt;触发器名&gt;</span><br><span class="line">      ｛BEFORE|AFTER｝ &lt;触发事件&gt; ON &lt;表名&gt;</span><br><span class="line">      REFERENCING NEW|OLD ROW AS &lt;变量&gt; -- 指出引用的变量</span><br><span class="line">      FOR EACH &#123;ROW|STATEMENT&#125;</span><br><span class="line">      [WHEN &lt;触发条件&gt;]&lt;触发动作&gt;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>要求：</p>
<ol>
<li>创建表的用户才可以创建触发器</li>
<li>触发器名可以包含模式名，可以不。触发器和表名必须在同一个模式下</li>
<li>表名只能在基本表上，视图上不行</li>
<li>触发事件可以是INSERT,DELETE,UPDATE的组合。</li>
<li>触发器类型<ul>
<li>行级：FOR EACH ROW</li>
<li>语句级：FOR EACH STATEMENT</li>
</ul>
</li>
<li>触发条件：没有WHEN就是立即执行；否则WHEN为真执行</li>
<li>触发动作体<ul>
<li>可以是SQL进程，也可以是已创建的存储过程的调用</li>
</ul>
</li>
</ol>
</li>
<li><p>触发器激活顺序</p>
<ol>
<li>BEFORE</li>
<li>激活触发器的SQL语句</li>
<li>AFTER</li>
</ol>
</li>
<li><p>删除：<code>DROP TRIGGER &lt;触发器名&gt; ON &lt;表名&gt;</code></p>
</li>
</ol>
<h2 id="关系数据理论"><a href="#关系数据理论" class="headerlink" title="关系数据理论"></a>关系数据理论</h2><h3 id="问题提出"><a href="#问题提出" class="headerlink" title="问题提出"></a>问题提出</h3><h3 id="规范化"><a href="#规范化" class="headerlink" title="规范化"></a>规范化</h3><ol>
<li>定义：设R(U)是属性集U上的关系模式，X,Y是U的子集。若对R(U)的任意一个可能的关系r，r中不可能存在两个元组在X上的属性值相等。</li>
</ol>
<h3 id="数据依赖的公理系统"><a href="#数据依赖的公理系统" class="headerlink" title="数据依赖的公理系统"></a>数据依赖的公理系统</h3><h3 id="模式分解"><a href="#模式分解" class="headerlink" title="模式分解"></a>模式分解</h3><h2 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ol>
<li>特点：三分技术、七分管理、十二分基础数据</li>
<li>数据库设计方法：<ol>
<li>新奥尔良方法</li>
<li>基于E-R模型的设计方法</li>
<li>3NF的设计方法</li>
<li>面向对象的数据库设计方法</li>
<li>统一建模语言（UML）方法</li>
</ol>
</li>
<li><strong>数据库设计步骤</strong><ol>
<li>需求分析</li>
<li>概念结构设计</li>
<li>逻辑结构设计</li>
<li>物理结构设计</li>
<li>数据库实施</li>
<li>数据库运行和维护</li>
</ol>
</li>
<li><img src="/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/0%E6%95%B0%E6%8D%AE%E5%BA%93/image-20210830204728105.png" alt="image-20210830204728105" style="zoom:80%;">
1. 概念设计阶段形成独立于及其特点和各个DBMS的概念模式，在本篇中就是E-R图；
2. 逻辑设计阶段将E-R图转换成具体的数据库产品支持的数据模型，形成数据库逻辑模式。然后根据用户处理的要求、安全性的考虑，在基本表的基础上建立必要的视图，形成数据的外模式。
3. 物理结构设计阶段，根据DBMS的特点和处理的需要进行物理存储安排，建立索引，形成数据库内模式。</li>
</ol>
<h3 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h3><h3 id="概念结构设计"><a href="#概念结构设计" class="headerlink" title="概念结构设计"></a>概念结构设计</h3><h3 id="逻辑结构设计"><a href="#逻辑结构设计" class="headerlink" title="逻辑结构设计"></a>逻辑结构设计</h3><h3 id="物理结构设计"><a href="#物理结构设计" class="headerlink" title="物理结构设计"></a>物理结构设计</h3><h3 id="数据库实施与维护"><a href="#数据库实施与维护" class="headerlink" title="数据库实施与维护"></a>数据库实施与维护</h3><h2 id="数据库编程"><a href="#数据库编程" class="headerlink" title="数据库编程"></a>数据库编程</h2><h3 id="嵌入式SQL"><a href="#嵌入式SQL" class="headerlink" title="嵌入式SQL"></a>嵌入式SQL</h3><p>数据库工作单元与源程序工作单元之间的通信：</p>
<ol>
<li><p>向主语句传递SQL语句的执行状态信息，使主语言根据信息控制程序流程，主要通过**SQL通信区($SQLCA$)**实现。</p>
<ul>
<li>SQL通信区用$EXEC\ SQL\ INCIUDE\ SQLCA$定义。$SQLCODE$用来存放每次执行SQL语句后返回的代码</li>
</ul>
</li>
<li><p>主语言向SQL提供参数，通过<strong>主变量（host varilable）</strong>实现。</p>
<ul>
<li><p>主变量可以附带一个指示变量，用作指示主变量的值或者条件（检测输入/输出是否空值，值是否被截断）</p>
</li>
<li><p>通过$BEGIN\ DECLARE\ SECTION$与$END\ DECLARE\ SECTION$之间进行说明</p>
</li>
<li><p>主变量和指示变量前要加冒号作为标志</p>
</li>
</ul>
</li>
<li><p>将SQL语句查询数据库的结构交主语言处理，主要用<strong>主变量和游标（cursor）</strong>实现。</p>
<ul>
<li>用作平衡“一条SQL语句可以产生或处理多条记录”和“一次主变量一次只能存放一条记录”</li>
<li><strong>游标：系统开设的一个数据缓冲区，存放SQL语句的执行结果，每个游标区都有一个名字。</strong></li>
<li><strong>用户可以通过游标逐一获取记录赋值给主变量，交由主语言进一步处理。</strong></li>
</ul>
</li>
<li><p>嵌入式SQL需要建立连接才能访问数据库</p>
<ul>
<li>$EXEC\ SQL\ CONNECT\ TO\ target$</li>
</ul>
</li>
<li><p>游标：</p>
<ol>
<li>不用游标的SQL语句：<ol>
<li>查询结果为单记录的SELECT语句</li>
<li>非CURRENT形式的增删改语句</li>
</ol>
</li>
<li>用游标的SQL语句：<ol>
<li>查询结果为多条记录的SELECET语句<ul>
<li>使用游标步骤<ul>
<li>说明游标$EXEC\ SQL\ DECLARE\ &lt;游标名&gt;\ CURSOR\ FOR &lt;SELECT语句&gt;$</li>
<li>打开游标$EXEC\ SQL\ OPEN\ &lt;游标名&gt;$</li>
<li>推进游标指针并取当前记录$EXEC\ SQL\ FETCH\ &lt;游标名&gt;\ INTO\ &lt;主变量&gt;[&lt;指示变量&gt;]$</li>
<li>关闭游标$EXEC\ SQL\ CLOSE\ &lt;游标名&gt;$</li>
</ul>
</li>
</ul>
</li>
<li>CURRENT形式的UPDATE和DELETE语句<ul>
<li>CURRENT形式：UPDATE和DELETE语句中要用子句$WHERE\ CURRENT\ OF\ &lt;游标名&gt;$</li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="过程化SQL"><a href="#过程化SQL" class="headerlink" title="过程化SQL"></a>过程化SQL</h3><img src="/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/0%E6%95%B0%E6%8D%AE%E5%BA%93/image-20210830212226698.png" alt="image-20210830212226698" style="zoom: 50%;">

<img src="/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/0%E6%95%B0%E6%8D%AE%E5%BA%93/image-20210830212244848.png" alt="image-20210830212244848" style="zoom: 50%;">



<h3 id="存储过程和函数"><a href="#存储过程和函数" class="headerlink" title="存储过程和函数"></a>存储过程和函数</h3><h3 id="开放数据库互连（ODBC）"><a href="#开放数据库互连（ODBC）" class="headerlink" title="开放数据库互连（ODBC）"></a>开放数据库互连（ODBC）</h3><p>不同DBMS之间共享数据</p>
<h3 id="OLE-DB"><a href="#OLE-DB" class="headerlink" title="OLE DB"></a>OLE DB</h3><h3 id="Java数据库连接（JDBC）"><a href="#Java数据库连接（JDBC）" class="headerlink" title="Java数据库连接（JDBC）"></a>Java数据库连接（JDBC）</h3><h2 id="关系查询处理和查询优化"><a href="#关系查询处理和查询优化" class="headerlink" title="关系查询处理和查询优化"></a>关系查询处理和查询优化</h2><h2 id="数据库恢复技术"><a href="#数据库恢复技术" class="headerlink" title="数据库恢复技术"></a>数据库恢复技术</h2><h3 id="事务基本概念"><a href="#事务基本概念" class="headerlink" title="事务基本概念"></a>事务基本概念</h3><ol>
<li>定义：用户定义的一个数据库操作序列，这些操作要么全做，要么全不做，是一个不可分割的工作单位</li>
<li><strong>特性：</strong>ACID特性<ol>
<li>原子性：事务中的操作要么都不做，要么都做</li>
<li>一致性：事务执行的结果使数据库从一个一致性状态到另一个一致性状态</li>
<li>隔离性（isolation）：事务的执行不能被其他事务干扰</li>
<li>持续性（durability）：事务造成的改变应该是永久性的，接下来的其他操作对其执行结果不应该有影响</li>
</ol>
</li>
<li>影响ACID特性的因素：<ol>
<li>并行运行事务</li>
<li>事务被强制停止</li>
</ol>
</li>
</ol>
<h3 id="恢复概述"><a href="#恢复概述" class="headerlink" title="恢复概述"></a>恢复概述</h3><h3 id="故障种类"><a href="#故障种类" class="headerlink" title="故障种类"></a>故障种类</h3><ol>
<li>分类<ol>
<li>事务内部故障</li>
<li>系统故障</li>
<li>介质故障</li>
<li>计算机病毒</li>
</ol>
</li>
<li>解决： 冗余</li>
</ol>
<h3 id="恢复的实现技术"><a href="#恢复的实现技术" class="headerlink" title="恢复的实现技术"></a>恢复的实现技术</h3><ol>
<li>数据转储<ol>
<li>静态转储<ol>
<li>转储期间不允许对数据库的任何存取、修改</li>
<li>一定是数据一致性的副本</li>
</ol>
</li>
<li>动态转储<ol>
<li>转储期间不允许对数据库的任何存取、修改</li>
<li>数据不一定正确有效</li>
</ol>
</li>
<li>海量：转储全部数据库；增量：转储上一次转储更新过的</li>
<li>动态海量；动态增量；静态海量；静态增量</li>
</ol>
</li>
<li>登记日志文件：先写日志文件，后写数据库</li>
</ol>
<h3 id="恢复策略"><a href="#恢复策略" class="headerlink" title="恢复策略"></a>恢复策略</h3><ol>
<li>事务故障恢复</li>
<li>系统故障恢复</li>
<li>介质故障恢复</li>
</ol>
<h3 id="检查点"><a href="#检查点" class="headerlink" title="检查点"></a>检查点</h3><ol>
<li>记录了建立检查点时所有正在执行的事务清单</li>
<li>这些事务最近一个日志记录的地址</li>
</ol>
<h3 id="数据库镜像"><a href="#数据库镜像" class="headerlink" title="数据库镜像"></a>数据库镜像</h3><h2 id="并发控制"><a href="#并发控制" class="headerlink" title="并发控制"></a>并发控制</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><ul>
<li>并发操作带来的数据不一致性：（破坏了事务的隔离性）<ul>
<li>丢失修改：两个事务，一个事务的提交破坏了另一个事务的修改</li>
<li>不可重复读：事务1读取数据后，事务2更新（增删改）了数据，导致事务1无法重读</li>
<li>读脏数据：事务1修改了数据，之后事务2读取了，接着事务1撤销了修改，则事务2读取的数据就是脏数据</li>
</ul>
</li>
<li>并发控制的主要技术：<ul>
<li>封锁</li>
<li>时间戳</li>
<li>乐观控制法</li>
<li>多版本并发控制（MVCC）</li>
</ul>
</li>
</ul>
<h3 id="封锁"><a href="#封锁" class="headerlink" title="封锁"></a>封锁</h3><ol>
<li>定义：事务对数据对象操作期间加锁，其他事务不能对其进行修改。</li>
<li>分类：<ol>
<li>排他锁/写锁（X锁）<ul>
<li>只允许加锁的事务对数据对象进行读取与修改</li>
</ul>
</li>
<li>共享锁/读锁（S锁）<ul>
<li>加锁的事务只能读取不能修改，其它事务可以加S锁，但是不能加X锁</li>
</ul>
</li>
</ol>
</li>
</ol>
<h3 id="封锁协议"><a href="#封锁协议" class="headerlink" title="封锁协议"></a>封锁协议</h3><ol>
<li>定义：规定加锁的事件、持续时间、释放时间</li>
<li>一级封锁协议：（可以防止丢失修改，保证事务可恢复）<ol>
<li>事务修改数据前加X锁，事务结束才释放</li>
<li>如果仅仅读数据，则不需加锁。因此无法保证可重复读和不读脏数据</li>
</ol>
</li>
<li>二级封锁协议：（可以防止丢失修改、读脏数据）<ol>
<li>在一级封锁协议基础上增加事务在读取数据之前必须对其加S锁，<strong>读完之后可以释放S锁。</strong></li>
</ol>
</li>
<li>三级封锁协议：（防止丢失修改、读脏数据、读脏数据）<ol>
<li>在一级的基础上增加事务读取数据之前对其加S锁，<strong>直到事务结束才释放。</strong></li>
</ol>
</li>
<li><img src="/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/0%E6%95%B0%E6%8D%AE%E5%BA%93/image-20210830231956904.png" alt="image-20210830231956904"></li>
</ol>
<h3 id="活锁死锁"><a href="#活锁死锁" class="headerlink" title="活锁死锁"></a>活锁死锁</h3><ol>
<li>活锁：一直等待得不到加锁<ol>
<li>避免活锁：先来先服务</li>
</ol>
</li>
<li>死锁：事务1封锁了数据1，事务2封锁了数据2；事务1申请封锁数据2，事务2又申请封锁数据1；这就造成了两个事务互相等待，永远等不到，造成死锁。<ol>
<li>预防死锁：<ol>
<li>一次封锁法：事务对所有要使用的数据全部加锁。<ol>
<li>缺点：降低了并发度；难以确定哪些对象需要封锁</li>
</ol>
</li>
<li>顺序封锁法：预先对数据规定一个封锁顺序，所有事务按照这个顺序实施封锁<ol>
<li>缺点：成本高、操作难；事务的封锁请求随执行动态变化，难以确定顺序</li>
</ol>
</li>
</ol>
</li>
<li>死锁的诊断：<ol>
<li>超时法<ol>
<li>缺点：可能存在误判；可能不能及时发现死锁</li>
</ol>
</li>
<li>等待图法<ol>
<li>图中存在回路，表示有死锁</li>
</ol>
</li>
</ol>
</li>
<li>解决死锁：撤销一个代价最小的事务，事后加以恢复</li>
</ol>
</li>
</ol>
<h3 id="并发调度的可串行性"><a href="#并发调度的可串行性" class="headerlink" title="并发调度的可串行性"></a>并发调度的可串行性</h3><h3 id="两段锁协议（2PL）"><a href="#两段锁协议（2PL）" class="headerlink" title="两段锁协议（2PL）"></a>两段锁协议（2PL）</h3><ol>
<li>两段锁协议：<ol>
<li>在对任何数据读写之前，首先要申请和获得其它任何封锁</li>
<li>释放一个锁之后，事务不再申请和获得其他封锁</li>
</ol>
</li>
<li>两段：<ol>
<li>第一阶段/扩展阶段：获得封锁</li>
<li>第二阶段/收缩阶段：释放封锁</li>
</ol>
</li>
<li><img src="/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/0%E6%95%B0%E6%8D%AE%E5%BA%93/image-20210830233001305.png" alt="image-20210830233001305" style="zoom:80%;"></li>
<li>遵守两段锁，一定可以串行化；可串行化并不一定符合两段锁</li>
</ol>
<h3 id="封锁的力度"><a href="#封锁的力度" class="headerlink" title="封锁的力度"></a>封锁的力度</h3><h3 id="其它并发控制机制"><a href="#其它并发控制机制" class="headerlink" title="其它并发控制机制"></a>其它并发控制机制</h3><h2 id="DBMS"><a href="#DBMS" class="headerlink" title="DBMS"></a>DBMS</h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://naixil.github.io/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/1%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Li Xian">
      <meta itemprop="description" content="与遗忘作斗争">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LiXian's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/1%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" class="post-title-link" itemprop="url">数据结构</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-09-01 12:08:43" itemprop="dateCreated datePublished" datetime="2021-09-01T12:08:43+08:00">2021-09-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-09-25 21:21:44" itemprop="dateModified" datetime="2021-09-25T21:21:44+08:00">2021-09-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/" itemprop="url" rel="index"><span itemprop="name">计算机基础知识总结</span></a>
                </span>
            </span>

          
            <span id="/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/1%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" class="post-meta-item leancloud_visitors" data-flag-title="数据结构" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/1%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/1%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>9.4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>9 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="数据结构（王道考研，笔记）"><a href="#数据结构（王道考研，笔记）" class="headerlink" title="数据结构（王道考研，笔记）"></a>数据结构（王道考研，笔记）</h1><h2 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h2><ol>
<li>数据结构（三要素）<ol>
<li><strong>逻辑结构</strong><ol>
<li>线性结构：线性表、栈、队列</li>
<li>非线性结构：树、图、集合</li>
</ol>
</li>
<li><strong>存储结构</strong>（物理结构）<ol>
<li>顺序存储：逻辑上相邻，物理上也相邻<ul>
<li>优点：可以实现随机存取，占用存储少</li>
<li>缺点：只能使用相邻的存储单元，因此可能产生较多的外部碎片</li>
</ul>
</li>
<li>链式存储：用指针表示元素之间的逻辑关系<ol>
<li>优点：不会出现碎片现象</li>
<li>缺点：指针的存储会占用额外的存储空间；只能实现顺序存取</li>
</ol>
</li>
<li>索引存储：建立索引表<ol>
<li>优点：检索速度快</li>
<li>缺点：索引表占据存储空间；增删数据耗时多</li>
</ol>
</li>
<li>散列存储<ol>
<li>优点：检索、增删操作很快</li>
<li>缺点：散列函数不好的话，可能出现元素单元的地址冲突，解决冲突会耗费时间和空间开销</li>
</ol>
</li>
</ol>
</li>
<li><strong>数据的运算：</strong>定义根据逻辑结构；实现根据存储结构<ul>
<li>数据类型：一个值的集合，和定义在此集合上的一组操作的总称。<ol>
<li>原子类型</li>
<li>结构类型</li>
</ol>
</li>
<li>抽象数据类型，ADT：抽象数据组织及与之相关的操作</li>
</ul>
</li>
</ol>
</li>
<li>五个特征<ol>
<li>算法定义：对特定问题</li>
<li>五个特征：有穷性、确定性、可行性、输入（0或多）、输出（1或多）</li>
<li>好算法的特质：正确性、可读性、健壮性、高效率与低存储需求。</li>
<li>效率度量<ol>
<li>时间复杂度<ul>
<li>常见的渐进时间复杂度：常对幂指阶</li>
<li>计算：分析最深循环里面的基本操作</li>
</ul>
</li>
<li>空间复杂度<ul>
<li>原地工作：辅助空间为常量，即$O(1)$</li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<p>$O(1)\lt O(log_2n)\lt O(n)\lt O(nlog_2n)\lt O(n^2)\lt O(n^3)\lt O(2^n)\lt O(n!)\lt O(n^n)$</p>
<h2 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h2><h3 id="线性表的定义和基本操作"><a href="#线性表的定义和基本操作" class="headerlink" title="线性表的定义和基本操作"></a>线性表的定义和基本操作</h3><h4 id="线性表的定义"><a href="#线性表的定义" class="headerlink" title="线性表的定义"></a>线性表的定义</h4><p>具有相同数据类型的$n(n\ge 0)$个数据元素的<strong>有限</strong>序列。</p>
<p>常用$L$表示线性表，$L=(a_1,a_2,…,a_i, a_{i+1},…a_n)$。</p>
<h4 id="线性表的基本操作"><a href="#线性表的基本操作" class="headerlink" title="线性表的基本操作"></a>线性表的基本操作</h4><p>基本操作：创建销毁、增删改查</p>
<h3 id="顺序表示"><a href="#顺序表示" class="headerlink" title="顺序表示"></a>顺序表示</h3><h4 id="顺序表的定义"><a href="#顺序表的定义" class="headerlink" title="顺序表的定义"></a>顺序表的定义</h4><p>线性表的顺序存储又称<strong>顺序表</strong>。</p>
<p>特点：逻辑顺序与物理顺序相同。</p>
<p>顺序表的长度可以静态分配，也可以动态分配（通过<strong>指针</strong>实现）。</p>
<h4 id="顺序表顺序表上基本操作"><a href="#顺序表顺序表上基本操作" class="headerlink" title="顺序表顺序表上基本操作"></a>顺序表顺序表上基本操作</h4><p>线性表的元素位序是从1开始的，数组是从0开始的。</p>
<ol>
<li>插入<ul>
<li><img src="/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/1%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210826214602800.png" alt="image-20210826214602800"></li>
<li>时间复杂度$O(n)$</li>
</ul>
</li>
<li>删除<ul>
<li><img src="/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/1%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210826214718110.png" alt="image-20210826214718110"></li>
<li>时间复杂度$O(n)$</li>
</ul>
</li>
<li>查找<ul>
<li><img src="/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/1%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210826214804310.png" alt="image-20210826214804310"></li>
<li>时间复杂度$O(n)$</li>
</ul>
</li>
</ol>
<h3 id="链式表示"><a href="#链式表示" class="headerlink" title="链式表示"></a>链式表示</h3><h4 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h4><ol>
<li>定义：每个节点除了存放数据元素之外，还要存储指向下一个节点的指针。<ol>
<li>优点：不要求大片连续空间，改变容量方便。</li>
<li>缺点：不可随机存取，要耗费一定空间存放指针。</li>
</ol>
</li>
<li>实现<ol>
<li>使用<strong>头指针</strong>来标识一个单链表，在单链表第一个节点之前添加一个结点，称为<strong>头结点</strong>。<ol>
<li>区别：不管带不带头结点，头指针时钟指向链表的第一个节点；头结点通常不存储信息。</li>
<li><strong>头结点的优点</strong>：使得对第一个位置的节点的操作和表的其他位置上的操作一致，无须进行特殊处理；无论链表是否为空，其头指针都指向头结点的非空指针，统一了空表与非空表。</li>
</ol>
</li>
<li>建立<ol>
<li>头插法：<ol>
<li>新的结点插入到表头</li>
<li>新的结点插入到表尾（需要添加尾指针）</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h4 id="单链表上基本操作"><a href="#单链表上基本操作" class="headerlink" title="单链表上基本操作"></a>单链表上基本操作</h4><h4 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h4><p>单链表只有一个指向其后继的指针，因此只能从头结点依次顺序地向后遍历。</p>
<p>为了克服单链表的缺点，引入了双链表。双链表有两个指针$prior、next$，分别指向其前驱结点与后继结点。</p>
<h4 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h4><ol>
<li>循环单链表<ul>
<li>表中最后一个结点的指针不指向NULL，而是指向头结点。</li>
<li>判空条件：头结点的指针是否等于头指针。</li>
</ul>
</li>
<li>循环双链表<ul>
<li>头结点的$prior$指向表尾结点</li>
</ul>
</li>
</ol>
<h4 id="静态链表"><a href="#静态链表" class="headerlink" title="静态链表"></a>静态链表</h4><p><img src="/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/1%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210826214804310.png" alt="image-20210826214804310"></p>
<img src="/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/1%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210826234556739.png" alt="image-20210826234556739" style="zoom:50%;">

<h4 id="顺序表和链表的比较"><a href="#顺序表和链表的比较" class="headerlink" title="顺序表和链表的比较"></a>顺序表和链表的比较</h4><table>
<thead>
<tr>
<th align="center">链表</th>
<th align="center">存取方式</th>
<th>逻辑结构与物理结构</th>
<th align="center">增删查</th>
<th>空间分配</th>
</tr>
</thead>
<tbody><tr>
<td align="center">顺序表</td>
<td align="center">顺序+随机</td>
<td>相邻</td>
<td align="center">按值查找，无序，$O(n)$，有序，$O(log_2n)$；按序号，$O(1)$</td>
<td>固定</td>
</tr>
<tr>
<td align="center">链表</td>
<td align="center">只能从头</td>
<td>不相邻，由指针表示</td>
<td align="center">按值查找，无序，$O(n)$，有序，$O(log_2n)$；按序号，$O(1)$</td>
<td>灵活</td>
</tr>
</tbody></table>
<ul>
<li>选择<ul>
<li>存储优先<ul>
<li>链表</li>
</ul>
</li>
<li>运算优先<ul>
<li>按序号访问频繁，则顺序表</li>
<li>插入删除频繁，则链表</li>
</ul>
</li>
<li>环境优先<ul>
<li>顺序表容易实现；链表基于指针。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h2><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><ol>
<li>定义：只允许在一端进行插入或删除操作的线性表。</li>
<li>数学性质：$n$个不同的元素进栈，出栈不同排列的个数$\frac 1 {n+1} C_{2n}^n$。卡特兰数。</li>
<li>基本操作<ul>
<li><img src="/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/1%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210827000056901.png" alt="image-20210827000056901"></li>
</ul>
</li>
<li>分类<ol>
<li>顺序栈<ul>
<li><img src="/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/1%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210827000514532.png" alt="image-20210827000514532" style="zoom: 33%;"></li>
<li>共享栈：两个栈的栈底分别设置在共享空间的两端。优点，有效利用存取空间，避免上溢。</li>
</ul>
</li>
<li>链式栈<ul>
<li><img src="/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/1%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210827000537045.png" alt="image-20210827000537045" style="zoom:33%;"></li>
</ul>
</li>
</ol>
</li>
</ol>
<h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><ol>
<li>定义：只允许在表的一端进行插入，而在表的另一端进行删除。</li>
<li>分类<ol>
<li>顺序队列<img src="/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/1%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210827001051969.png" alt="image-20210827001051969" style="zoom: 33%;"></li>
<li>循环队列<img src="/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/1%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210827001204423.png" alt="image-20210827001204423" style="zoom: 33%;"></li>
<li>链式队列<ul>
<li><img src="/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/1%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210827001301728.png" alt="image-20210827001301728" style="zoom: 33%;"><img src="/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/1%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210827001324400.png" alt="image-20210827001324400" style="zoom: 33%;"></li>
</ul>
</li>
<li>双端队列<ul>
<li><img src="/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/1%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210827001510029.png" alt="image-20210827001510029" style="zoom:33%;"></li>
</ul>
</li>
</ol>
</li>
</ol>
<h2 id="串"><a href="#串" class="headerlink" title="串"></a>串</h2><ol>
<li>定义：0个或者多个字符组成的有限序列。</li>
<li>串的匹配：<ol>
<li>暴力模式匹配</li>
<li>KMP算法<ol>
<li>由子串的<strong>最长相等前后缀长度</strong>构成部分匹配值（PM）表；</li>
<li>发现不匹配的时候移动位置=已匹配位数-对应的部分匹配值</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="树与二叉树"><a href="#树与二叉树" class="headerlink" title="树与二叉树"></a>树与二叉树</h2><h3 id="树的基本概念"><a href="#树的基本概念" class="headerlink" title="树的基本概念"></a>树的基本概念</h3><ol>
<li>特点<ol>
<li>树的根节点没有前驱，除了根节点之外所有节点只有一个后继。</li>
<li>树中的所有结点可以有0个或者多个后继</li>
</ol>
</li>
<li>性质：<ol>
<li>结点数等于所有节点的出度+1</li>
<li>度为m的树中第$i$层至多有$m^{i-1}$个结点</li>
<li>高度为h的m叉树至多由$\frac {m^h-1} {n-1}$个结点</li>
<li>具有n个结点的m叉树最小高度为$\lceil log_m(n(m-1)+1)\rceil$</li>
</ol>
</li>
</ol>
<h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><p>分叉$\le $2</p>
<ol>
<li><p>特殊的二叉树</p>
<ol>
<li>满二叉树<ul>
<li>高度为h，具有$2^h-1$个结点的二叉树    </li>
</ul>
</li>
<li>完全二叉树<ul>
<li>高度为h，有n个结点的二叉树，n与满二叉树中$1\sim n$对应</li>
</ul>
</li>
<li>二叉排序树<ol>
<li>左子树上所有结点的关键字均小于根</li>
<li>右子树所有结点关键字均大于根</li>
<li>左子树和右子树均是二叉排序树</li>
</ol>
</li>
<li>平衡二叉树<ol>
<li>任一节点的左子树右子树深度之差不超过1</li>
</ol>
</li>
</ol>
</li>
<li><p>二叉树性质</p>
<ol>
<li>非空二叉树叶子结点数等于度为2的结点数+1</li>
<li>非空二叉树第k层至多$2^{k-1}$个结点</li>
<li>高度为h的二叉树至多$2^{h}-1$个结点</li>
<li>具有n个结点的完全2叉树最小高度为$\lceil log_2(n+1)\rceil$</li>
</ol>
</li>
<li><p>二叉树的遍历（根节点N，左子树L，右子树R）</p>
<ul>
<li><p>方法</p>
<ul>
<li><img src="/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/1%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210827152052317.png" alt="image-20210827152052317" style="zoom:50%;"></li>
<li><p>先序遍历NLR：124635</p>
<ol>
<li>访问根节点</li>
<li>先序遍历左子树</li>
<li>先序遍历右子树</li>
</ol>
</li>
<li><p>中序遍历LNR：264135</p>
<ol>
<li>中序遍历左子树</li>
<li>访问根节点</li>
<li>中序遍历右子树</li>
</ol>
</li>
<li><p>后序遍历LRN：642531</p>
<ol>
<li>后序遍历左子树</li>
<li>后序遍历右子树</li>
<li>访问根节点</li>
</ol>
</li>
<li><p>层次遍历:123456</p>
<ul>
<li>将根入队，根出队；</li>
<li>若根有左子树，左子树根节点入队；有右子树，右子树根节点入队；</li>
<li>左子树/右子树出队，分别执行2，3</li>
</ul>
</li>
</ul>
</li>
<li><p>由遍历序列构建二叉树</p>
<ul>
<li>由先序序列和中序序列可以唯一确定一颗二叉树</li>
<li>由后序序列和中序序列可以唯一确定一颗二叉树</li>
<li>由层序序列和中序序列也可以唯一确定一颗二叉树</li>
<li><strong>先序后序不能确定二叉树</strong></li>
</ul>
</li>
</ul>
</li>
<li><p>线索二叉树</p>
<ol>
<li>定义：二叉树的基础上，若无左子树，令$lchild$指向其前驱结点；若无右子树，令其$rchild$指向其后继结点。还需要添加标志位，用来判定指针指向的是孩子结点（$0$）还是前驱后继结点（$1$）。</li>
<li>中序线索二叉树<ol>
<li><img src="/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/1%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210827153544608.png" alt="image-20210827153544608" style="zoom:67%;"></li>
</ol>
</li>
<li>相应有先序线索二叉树，后续线索二叉树<ul>
<li><img src="/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/1%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210827160758537.png" alt="image-20210827160758537"></li>
</ul>
</li>
</ol>
</li>
</ol>
<h3 id="树、森林"><a href="#树、森林" class="headerlink" title="树、森林"></a>树、森林</h3><ol>
<li>树的存储结构<ol>
<li>双亲表示法<ul>
<li>每个结点设置一个伪指针，指示其双亲结点在数组中的位置</li>
<li><img src="/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/1%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210827162041861.png" alt="image-20210827162041861"></li>
<li>评价：<ul>
<li>优点：很快得到每个结点的双亲结点</li>
<li>缺点：求结点的孩子的时候需要遍历整个结构</li>
</ul>
</li>
</ul>
</li>
<li>孩子表示法<ol>
<li>每个结点的孩子结点都用单链表链接起来形成一个线性结构。</li>
<li><u><em>见下图5-15(a)，原图是5-13(a)的情况，修改后的是5-15（b）的对应孩子表示法</em></u></li>
<li>评价：<ol>
<li>优点：寻找子女快</li>
<li>缺点：寻找双亲需要遍历n个结点中孩子链表指针域所指向的n个孩子链表</li>
</ol>
</li>
</ol>
</li>
<li>孩子兄弟表示法/二叉树表示法<ol>
<li>每个结点包括：<ol>
<li>结点值</li>
<li>指向结点第一个孩子结点的指针</li>
<li>指向结点下一个兄弟结点的指针</li>
</ol>
</li>
<li><img src="/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/1%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210827164603030.png" alt="image-20210827164603030"></li>
</ol>
</li>
</ol>
</li>
<li>树、森林和二叉树的转换<ol>
<li>树转换成二叉树规则<ul>
<li><strong>左孩子右兄弟：</strong>每个结点<strong>左指针</strong>指向它的<strong>第一个孩子</strong>，<strong>右指针</strong>指向<strong>它在树的相邻右兄弟</strong>，</li>
</ul>
</li>
<li>画法<ol>
<li>在兄弟之间加连线</li>
<li>对每个结点只保留它与第一个孩子的连线，与其它孩子的连线都抹去</li>
<li>以树根为轴心，顺时针旋转45度</li>
<li><img src="/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/1%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210827175236848.png" alt="image-20210827175236848" style="zoom:50%;"></li>
</ol>
</li>
<li>森林与二叉树：<img src="/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/1%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210827175336538.png" alt="image-20210827175336538"></li>
</ol>
</li>
<li>树和森林的遍历<ol>
<li>树的遍历<ol>
<li>先根遍历<ol>
<li>树非空则访问根节点，再依次遍历根节点的每棵子树，遍历子树是仍然先根后子树。<strong>遍历顺序与这棵树相应二叉树的==先序序列==相同</strong></li>
</ol>
</li>
<li>后根遍历<ol>
<li>树非空则先依次遍历根结点的子树，再访问根节点，遍历子树是仍然先子树后根。<strong>遍历顺序与这棵树相应二叉树的==中序序列==相同</strong></li>
</ol>
</li>
</ol>
</li>
<li>森林<ol>
<li>先序遍历<ol>
<li>访问第一棵树的根节点</li>
<li>先序遍历第一棵树中根节点的子树森林</li>
<li>先序遍历除去第一棵树之后剩余的树构成的森林</li>
<li>图5.17：$ABCDEFGHI$(与对应二叉树先序相同)</li>
</ol>
</li>
<li>中序遍历<ol>
<li>中序遍历第一棵树中根节点的子树森林</li>
<li>访问第一棵树的根节点</li>
<li>中序遍历除去第一棵树之后剩余的树构成的森林</li>
<li>图5.17：$BCDAFEHIG$</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="树与二叉树应用"><a href="#树与二叉树应用" class="headerlink" title="树与二叉树应用"></a>树与二叉树应用</h3><h4 id="二叉排序树（-BST-）"><a href="#二叉排序树（-BST-）" class="headerlink" title="二叉排序树（$BST$）"></a>二叉排序树（$BST$）</h4><ol>
<li>定义：或者是空树，或者非空；若非空<ol>
<li>若左子树非空，左子树所有结点的值均小于根结点的值</li>
<li>若右子树非空，右子树所有结点的值均大于根结点的值</li>
<li>左右子树 分别是一颗二叉排序树</li>
</ol>
</li>
<li>性质：对二叉排序树进行中序遍历，得到一个递增的有序序列。</li>
<li>二叉排序树的查找<ul>
<li>与根比较大小，如果大于根，则去右子树；如果小于根，则去左子树。</li>
</ul>
</li>
<li>二叉排序树的插入<ul>
<li>空树直接插入。非空则和排序类似，插入的节点一定是一个新添加的叶结点，且是查找失败时查找路径上访问的最后一个结点的左海子或者右孩子。</li>
</ul>
</li>
<li>二叉排序树的构造：就是不断的进行插入</li>
<li>二叉树的删除<ol>
<li>叶结点直接删除</li>
<li>若被删除结点z只有一颗左子树或右子树，则让z的直接后继或者直接前驱成为z父节点的子树</li>
<li>若z有两棵子树，令z的直接后继或者直接前驱代替z，然后从二叉树中删除这个直接前驱或直接后继。</li>
<li>图示：<img src="/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/1%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210827204015500.png" alt="image-20210827204015500"></li>
</ol>
</li>
<li>二叉树查找效率分析<ol>
<li>若左右子树高度之差不超过1，称为平衡二叉树。其平均查找长度为$O(log_2n)$。若二叉排序树是只有一个左/右孩子的单支树，平均查找长度为$O(n)$</li>
<li>图示：<img src="/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/1%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210827204232677.png" alt="image-20210827204232677"></li>
<li><strong>如果只做查询操作，用顺序表，方法用二分查找；如果有增删查，用二叉树。</strong></li>
</ol>
</li>
</ol>
<h4 id="平衡二叉树（Balanced-Binary-Tree）"><a href="#平衡二叉树（Balanced-Binary-Tree）" class="headerlink" title="平衡二叉树（Balanced Binary Tree）"></a>平衡二叉树（Balanced Binary Tree）</h4><ol>
<li>左右子树高度相差不超过1的二叉排序树。</li>
<li>插入：<ol>
<li>LL平衡旋转：在A的左孩子（L）的左子树（L）上插入新的结点。将A的左孩子B向右上旋转成为根节点，A成为B的右孩子，B的原来的右子树作为A的左子树。<img src="/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/1%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210827204713413.png" alt="image-20210827204713413"></li>
<li>RR平衡旋转：在A的右孩子（R）的右子树（R）插入。<img src="/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/1%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210827205000283.png" alt="image-20210827205000283"></li>
<li>LR平衡旋转：<img src="/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/1%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210827205127787.png" alt="image-20210827205127787"></li>
<li>RL平衡旋转：<img src="/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/1%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210827205302957.png" alt="image-20210827205302957"></li>
</ol>
</li>
<li>平衡二叉树查找效率分析<ol>
<li>n个结点的树的最大深度$O(log_2n)$</li>
<li>平均查找长度$O(log_2n)$</li>
</ol>
</li>
</ol>
<h4 id="哈夫曼树与哈夫曼编码"><a href="#哈夫曼树与哈夫曼编码" class="headerlink" title="哈夫曼树与哈夫曼编码"></a>哈夫曼树与哈夫曼编码</h4><ol>
<li><p>定义：结点常常被赋予值，称为该结点的权。从树的根结点到任意结点的路径长度与该结点上权值的乘积，称为该结点的<strong>带权路径长度</strong>。树中所有**==叶结点==**的带权路径长度之和称为该树的带权路径长度。<br>$$<br>WPL = \sum_{i=1}^nw_il_i<br>$$<br>$WPL$最小的二叉树称为哈夫曼树，也称为最优二叉树。</p>
</li>
<li><p>构造方法</p>
<ol>
<li>$n$个结点作为一个结点的二叉树，从里选出来权值最小的两个构造成二叉树。</li>
<li>此时有$n-1$个树，重复步骤1</li>
</ol>
</li>
<li><p><strong>哈夫曼编码</strong></p>
<ul>
<li><strong>前缀编码</strong>：没有一个编码是另一个编码的前缀。</li>
<li>方法：先根据字符的出现次数写出前缀编码，然后根据其出现次数构造哈夫曼树。</li>
<li><img src="/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/1%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210827220457719.png" alt="image-20210827220457719"><ul>
<li>$WPL=1<em>45+3</em>(12+13+16)+4*(5+9)=224$</li>
<li>也就是编码该段数据所需位数。对比定长编码（6个字符，3位二进制表示:<ul>
<li>$3*(45+12+13+5+9+16)=300$）</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><h3 id="图的基本概念"><a href="#图的基本概念" class="headerlink" title="图的基本概念"></a>图的基本概念</h3><ol>
<li>定义，图$G$由顶点集V和边集E组成，记为$G=(V,E)$，其中$V(G)$表示图$G$顶点的有限非空集；$E(G)$表示图$G$中顶点之间的边集合。$|V|,|G|$分别表示图的顶点个数（也称为阶）、边数。<strong>注意：</strong>图不能是空集，至少有一个顶点。</li>
<li>分类：<ol>
<li>有向图</li>
<li>无向图</li>
<li>简单图：不存在重复边；不存在顶点到自身的边。</li>
<li>多重图：两个结点之间的边数多于一条，又允许顶点通过同一条边和自己关联，则G为多重图。</li>
<li>完全图/简单完全图：边数为$n(n-1)/2$条边的无向图；或者有$n(n-1)$条边的有向图。</li>
<li>子图：$G=(V,E),G’=(V’,E’),V’$是$V$的子集，$E’$是$E$的子集，称$G’$为$G$的生成子图。</li>
<li>连通、连通图和连通分量：<ol>
<li>连通：从顶点v到顶点w有路径存在</li>
<li>连通图：图$G$中任意两个点都是连通的</li>
<li>连通分量：无向图中的极大连通子图。</li>
</ol>
</li>
<li>强连通图：<ol>
<li>顶点$v$到顶点$w$之间和顶点$w$到顶点$v$之间都有路径，称两个顶点之为强连通的。</li>
<li>若图中的任意一对顶点都是强连通的，称此图为强连通图。</li>
<li>强连通分量：有向图中的极大强连通子图称为有向图的强连通分量。</li>
</ol>
</li>
<li>生成树：包含图中所有顶点的一个极小连通子图。</li>
<li>顶点的度<ol>
<li>无向图：度等于2倍边数</li>
<li>有向图：入度等于出度等于边数</li>
</ol>
</li>
<li><img src="/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/1%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210828160705069.png" alt="image-20210828160705069" style="zoom: 25%;"></li>
<li><img src="/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/1%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210828160720498.png" alt="image-20210828160720498" style="zoom: 25%;"></li>
<li><img src="/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/1%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210828160736311.png" alt="image-20210828160736311" style="zoom: 25%;"></li>
<li>边的权和网：边可以标上具有含义的数值，称为权值。带权图又称为网。</li>
<li>路径长度：路径上边的数目；回路，图有$n$个点，如果有大于$n-1$条边，必有回路。</li>
<li>有向树：一个顶点的入度为0，其它顶点的入度均为1的有向图，称为有向树。</li>
</ol>
</li>
</ol>
<h3 id="图的存储和基本操作"><a href="#图的存储和基本操作" class="headerlink" title="图的存储和基本操作"></a>图的存储和基本操作</h3><ol>
<li>邻接矩阵法：<img src="/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/1%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210828161939448.png" alt="image-20210828161939448" style="zoom:33%;"><ul>
<li>特点：<ul>
<li>对无向图：每一行的非零元素的个数正好是结点的度；对有向图：每一行非0元素个数正好是结点的出度，每一列非0元素个数正好是结点的入度。</li>
</ul>
</li>
</ul>
</li>
<li>邻接表法：<ul>
<li><img src="/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/1%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210828162520063.png" alt="image-20210828162520063" style="zoom:33%;"></li>
<li><img src="/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/1%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210828162533557.png" alt="image-20210828162533557" style="zoom:33%;"></li>
<li>评价：<ul>
<li>对于稀疏图能节省存储空间</li>
<li>很容易找到所有邻边</li>
<li>判断两个顶点之间是否有边，邻接矩阵快，邻接表慢。</li>
<li>出度好算，入度不好算。</li>
<li>邻接表顺序不唯一</li>
</ul>
</li>
</ul>
</li>
<li>十字链表（针对有向图）<ul>
<li><img src="/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/1%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210828162846177.png" alt="image-20210828162846177"></li>
<li>画法：<ul>
<li>先画出来三个格子的每个点</li>
<li>每个点所在的行按照位置在第二个格子画上并写上对应的弧指向的点，再一行的格子都连起来</li>
<li>行号如果与其他行四个格子中的第二个格子的一样则连起来；每一列由多于一个相同第二个格子的，按照从上到下的顺序连起来。</li>
</ul>
</li>
</ul>
</li>
<li>邻接多重表（针对无向图）</li>
</ol>
<h3 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h3><ol>
<li>广度优先搜索（BFS）<ul>
<li><img src="/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/1%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210829204330257.png" alt="image-20210829204330257" style="zoom:80%;"></li>
<li>性能分析：<ul>
<li>空间复杂度$O(|V|)$</li>
<li>时间复杂度，采用邻接表：$O(|V|+|E|)$；采用邻接矩阵：$O(|V|^2)$</li>
</ul>
</li>
<li><img src="/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/1%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210829204652633.png" alt="image-20210829204652633" style="zoom:50%;"></li>
</ul>
</li>
<li>深度优先搜索(DFS)：<ul>
<li>过程：首先访问图中的某一起始顶点v，然后由v出发，访问与v邻接且未被访问的任一顶点$w_1$，再访问与$w_1$邻接未被访问的任一顶点$w_2$，重复。当不能再继续向下访问的时候，依次退回到最近被访问的顶点，若它还有邻接结点未被访问过，则从该点开始继续上述搜索过程。</li>
<li>性能分析：<ul>
<li>空间复杂度$O(|V|)$</li>
<li>时间复杂度，采用邻接表：$O(|V|+|E|)$；采用邻接矩阵：$O(|V|^2)$</li>
</ul>
</li>
<li><img src="/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/1%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210829205204112.png" alt="image-20210829205204112" style="zoom:50%;"></li>
</ul>
</li>
</ol>
<h3 id="图的应用"><a href="#图的应用" class="headerlink" title="图的应用"></a>图的应用</h3><h4 id="最小生成树（MST）"><a href="#最小生成树（MST）" class="headerlink" title="最小生成树（MST）"></a>最小生成树（MST）</h4><ol>
<li>定义<ol>
<li>生成树：包含图中所有的顶点，并且只含有尽可能少的边</li>
<li>权值之和最小的生成树叫最小生成树</li>
</ol>
</li>
<li>性质：<ol>
<li>可能树形状不唯一（但是权值之和唯一）：当图的边权值互不相等，MST是唯一的；</li>
<li>MST的边数比顶点数少1，即G本身是一棵树时，G的最小生成树是它本身。</li>
</ol>
</li>
<li>普里姆算法（从顶点开始扩展MST）<ol>
<li><img src="/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/1%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210829205822091.png" alt="image-20210829205822091" style="zoom: 67%;"></li>
<li>时间复杂度$O(|V|^2)$</li>
<li>适用于边稠密的图</li>
</ol>
</li>
<li>克鲁斯卡尔算法（按照权值的递增次序选择合适的边来构造MST）<ol>
<li>不断选最小的边，直到连起来所有的顶点</li>
<li><img src="/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/1%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210829210103605.png" alt="image-20210829210103605" style="zoom:67%;"></li>
<li>时间复杂度$O(|E|log|E|)$，使用堆来存放边集合</li>
<li>适用于边稀疏而顶点较多的图</li>
</ol>
</li>
</ol>
<h4 id="最短路径问题"><a href="#最短路径问题" class="headerlink" title="最短路径问题"></a>最短路径问题</h4><ol>
<li>迪杰斯特拉算法（某一个顶点到其它各顶点）时间复杂度$O(|V|^2)$<ul>
<li><img src="/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/1%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210829210846951.png" alt="image-20210829210846951" style="zoom: 50%;"></li>
<li>不能解决边有负的权值的情况</li>
</ul>
</li>
<li>佛洛依德算法（每对顶点间最短路径）时间复杂度$O(|V|^3)$<ol>
<li><img src="/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/1%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210829211304063.png" alt="image-20210829211304063" style="zoom:67%;"></li>
</ol>
</li>
<li>拓扑排序（AOV网：顶点表示活动，有向边表示先后次序）<ol>
<li><img src="/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/1%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210829211925513.png" alt="image-20210829211925513" style="zoom:67%;"></li>
<li>上图顺序为$12435$</li>
</ol>
</li>
<li>关键路径（AOE网：顶点表示事件，边表示活动，权值表示开销）<ol>
<li>性质：顶点代表的事件发生后，从这个点出发的时间才能开始；进入顶点的活动都结束，顶点才能发生。</li>
<li><img src="/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/1%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210829213048611.png" alt="image-20210829213048611"></li>
<li><img src="/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/1%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210829212959912.png" alt="image-20210829212959912" style="zoom:67%;"></li>
</ol>
</li>
</ol>
<h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>平均查找长度($ASL$)</p>
<ol>
<li>静态查找变（只适合查询和检索元素属性）<ol>
<li>顺序查找</li>
<li>折半查找</li>
<li>散列查找</li>
</ol>
</li>
<li>动态查找表<ol>
<li>二叉排序树的查找</li>
<li>散列查找</li>
</ol>
</li>
</ol>
<h3 id="顺序查找和折半查找"><a href="#顺序查找和折半查找" class="headerlink" title="顺序查找和折半查找"></a>顺序查找和折半查找</h3><ol>
<li>顺序查找<ol>
<li>一般线性表的顺序查找<ol>
<li>$ASL_{成功}=\sum_{i=1}^n P_i(n-i+1)=\frac{n+1}{2}$ ， 每个元素的查找概率相等</li>
<li>$ASL_{不成功}=n+1$</li>
</ol>
</li>
<li>有序表的顺序查找<ol>
<li>$ASL_{成功}=\sum_{i=1}^n P_i(n-i+1)=\frac{n+1}{2}$ </li>
<li>$ASL_{不成功}=\sum_{j=1}^n q_i(l_j-1)=\frac{1+2+…+n+n}{n+1}=\frac{n}{2}+\frac{n}{n+1}$ ，$q_j$是到达第$j$个失败结点的概率；$l_j$是第$j$个失败结点的层数</li>
</ol>
</li>
</ol>
</li>
<li>折半查找/二分查找：适用于有序的顺序表<ol>
<li>$ASL_{成功}=\frac 1 n(1<em>1+2</em>2+3<em>4+4</em>8+…+h*2^{h-1})=log_2(n+1)-1 $ </li>
<li>时间复杂度$O(log_2 n)$</li>
</ol>
</li>
<li>分块查找/索引顺序查找<ol>
<li>块内无序，块间有序<img src="/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/1%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210831121412395.png" alt="image-20210831121412395" style="zoom:67%;"></li>
<li>平均查找长度等于索引查找长度$L_I$和块内查找长度$L_S$</li>
<li>查找表有b块，每块有s个记录<ol>
<li>都采用顺序查找时：$ASL_{成功}=L_I+L_S=\frac {b+1}{2} + \frac {s+1}{2}$</li>
<li>都采用折半查找：$ASL_{成功}=L_I+L_S=\lceil log_2(b+1)\rceil + \frac {s+1}{2}$</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="B树和B-树"><a href="#B树和B-树" class="headerlink" title="B树和B+树"></a>B树和B+树</h3><ol>
<li>B树：多路平衡查找树<ol>
<li>阶：所有孩子结点的孩子个数的最大值称为B树的阶，用m表示。</li>
<li>定义：要么是空树，要么是满足以下特性的m叉树：<ol>
<li>树中每个结点至多有m棵子树，即至多含有m-1个关键字</li>
<li>若根节点不是终端结点，则至少有两棵子树</li>
<li>除了根节点外所有的非叶子结点有$\lceil \frac m 2\rceil$棵子树，即至少有$\lceil \frac m 2\rceil - 1$个关键字</li>
<li>所有非叶子结点结构如下，P是分界线，K是关键字。如示例，5,11是关键字，剩下三个地方是分界线<img src="/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/1%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210904092025148.png" alt="image-20210904092025148" style="zoom:67%;"></li>
<li>所有叶结点都在同一层上，且不带任何信息。叶结点代表查找失败。</li>
</ol>
</li>
<li>B树是所有结点平衡因子均等于0的多路平衡查找树</li>
<li>最大孩子数等于5，是一个5阶B树<img src="/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/1%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210904092149832.png" alt="image-20210904092149832"><ol>
<li>孩子结点个数等于关键字数+1</li>
<li>子树的个数等于关键字个数+1</li>
</ol>
</li>
<li>B树的高度不包括叶结点那一层<ul>
<li>对n个关键字、高度为h、阶数为m的B树，高度范围：$log_m(n+1)\le h \le log_{\lceil \frac m 2 \rceil}((\frac {n+1} 2)+1$</li>
<li>3阶B树，8个关键字，高度2~3.7</li>
</ul>
</li>
<li>B树的查找：在B树找结点（磁盘中）+在结点内找关键字（内存中）</li>
<li>插入结点：<img src="/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/1%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210904093818537.png" alt="image-20210904093818537"></li>
<li>删除结点：<ul>
<li><img src="/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/1%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210904093857662.png" alt="image-20210904093857662"><img src="/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/1%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210904093908415.png" alt="image-20210904093908415"></li>
</ul>
</li>
</ol>
</li>
<li>B+树：<img src="/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/1%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210904094033144.png" alt="image-20210904094033144"><img src="/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/1%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210904094209785.png" alt="image-20210904094209785"></li>
</ol>
<h3 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h3><ol>
<li>$Hash(key)=Addr,Addr$可以是数组下标、索引、内存地址。</li>
<li>可能会产生冲突。两个key映射到一个$Addr$</li>
<li>建立了关键字和存储地址之间的映射关系</li>
<li>散列函数的构造方法：<ol>
<li>直接定址法：$H(key)=key或H(key)=a*key + b $</li>
<li>除留取余法：$H(key)=key%p$，关键在选好$p$，$p$最好为一个不大于$m$但最接近或等于$m$的质数$p$，$m$为散列表长</li>
<li>数字分析法：r进制数中，r个数在某些位上分布均匀，某些上分布不均匀。应该选取分布较为均匀的若干位作为散列地址。</li>
<li>平方取中法：取关键字的平方值的中间几位作为散列地址。适用于关键字的每位取值都不够均匀或均小于散列地址所需的位数。</li>
</ol>
</li>
<li>冲突处理<ol>
<li>开放定址法：$H_1=(H(key) + d_i) % m$，$m$表示散列表长度，$d_i$为增量序列。<ul>
<li>$d_i$的选取：<img src="/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/1%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210904102032263.png" alt="image-20210904102032263"></li>
</ul>
</li>
<li>拉链法（散列到相同地址的关键字构建一个链表）：适用于经常插入删除的情况。<ul>
<li>$H(key)=key%13$<img src="/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/1%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210904102221259.png" alt="image-20210904102221259"></li>
</ul>
</li>
</ol>
</li>
</ol>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p><img src="/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/1%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210904102440753.png" alt="image-20210904102440753"></p>
<h3 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h3><ol>
<li>稳定性：两个元素$R_i,R_j$，其对应的关键字相同，且排序前$R_i$在$R_j$的前面，排序后仍然是$R_i$在$R_j$的前面，那么就称这个排序算法是稳定的。<ul>
<li>稳定性不能衡量算法的优劣</li>
</ul>
</li>
<li>分类（根据数据元素是否都在内存中）：<ol>
<li>内部排序</li>
<li>外部排序：排序期间元素无法全部同时存放在内存里，需要不断在内外存之间移动</li>
</ol>
</li>
<li>排序算法的基本操作：比较、移动。并非所有的排序算法都需要比较。（例如基数排序）</li>
</ol>
<h3 id="插入排序（待排序表-L-1-2-…-i-…-n-）"><a href="#插入排序（待排序表-L-1-2-…-i-…-n-）" class="headerlink" title="插入排序（待排序表$L[1,2,…,i,…,n]$）"></a>插入排序（待排序表$L[1,2,…,i,…,n]$）</h3><ol>
<li>直接插入排序<ul>
<li><img src="/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/1%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210904103343145.png" alt="image-20210904103343145"></li>
<li>空间复杂度$O(1)$</li>
<li>时间复杂度$O(n^2)$</li>
<li>稳定</li>
<li>适用于顺序存储和链式存储的线性表</li>
</ul>
</li>
<li>折半插入排序<ul>
<li>减小了比较次数。<img src="/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/1%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210904103802040.png" alt="image-20210904103802040"></li>
<li>空间复杂度$O(1)$</li>
<li>时间复杂度$O(n^2)$</li>
<li>稳定</li>
</ul>
</li>
<li>希尔排序/缩小增量排序<ul>
<li>先将待排序表分割成若干形如$L[i, i+d,i+2d,…,i+kd]$的子表，即把相隔某个增量的记录组成一个子表，对各个子表分别进行直接插入排序，当整个表中元素已呈现“基本有序”的时候，再对全体记录进行一次直接插入排序。</li>
<li>增量逐步为$5\rightarrow3\rightarrow1$<img src="/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/1%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210904104233294.png" alt="image-20210904104233294"></li>
<li>空间复杂度$O(1)$</li>
<li>最坏时间复杂度$O(n^2)$，当n在某个特定范围时，时间复杂度为$O(n^{1.3})$</li>
<li>不稳定</li>
<li>适用：线性表为顺序存储</li>
</ul>
</li>
</ol>
<h3 id="交换排序"><a href="#交换排序" class="headerlink" title="交换排序"></a>交换排序</h3><ol>
<li>冒泡排序<ul>
<li>从后往前的比较，每次都将最小的元素交换到第一个位置</li>
<li><img src="/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/1%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210904104545017.png" alt="image-20210904104545017"></li>
<li>空间复杂度$O(1)$</li>
<li>最坏时间复杂度$O(n^2)$，平均时间复杂度为$O(n^{2})$</li>
<li>稳定</li>
<li>适用：线性表为顺序存储</li>
</ul>
</li>
<li><strong>快速排序</strong>（基于分治法）<ul>
<li>一趟快速排序，随机取一个元素$pivot$，作为基准，通过一趟排序将排序表划分成比$pivot$大和比$pivot$小的两部分。</li>
<li>两个指针分别交替搜索<img src="/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/1%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210904105145078.png" alt="image-20210904105145078"><img src="/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/1%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210904105155082.png" alt="image-20210904105155082"></li>
<li>空间复杂度最好$O(log_2n)$，最坏$O(n)$，平均$O(log_2n)$</li>
<li>时间复杂度最好$O(nlog_2n)$，最坏$O(n^2)$，平均接近于$O(nlog_2n)$</li>
<li>不稳定</li>
<li>==快速排序是所有内部排序中平均性能最优的排序算法==；每次排序都会将基准元素$pivot$放到最终的位置</li>
</ul>
</li>
</ol>
<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>每一趟（如第$i$趟）在后面$n-i+1$个待排元素中选取关键字最小的元素，作为有序子序列的第$i$个元素直到第$n-1$趟。</p>
<ol>
<li>简单选择排序<ul>
<li>与冒泡排序区分：冒泡是交换（比较一次，则判断需不需要交换），简单选择是选择（记录位置，一趟比较结束再交换）</li>
<li>空间复杂度$O(1)$</li>
<li>时间复杂度$O(n^2)$</li>
<li>不稳定</li>
</ul>
</li>
<li>堆排序<ul>
<li>一个完全二叉树，父结点都比子结点大（称为大根堆）；或者都比子结点小（称为小根堆）</li>
<li>构造：<ul>
<li>n个结点的完全二叉树，对第$\lfloor\frac n 2\rfloor$个结点为根的子树筛选，使该子树成为堆；之后$(\lfloor\frac n 2\rfloor-1)\sim1$逐步进行筛选构造。</li>
<li>构造过程：不断构造子树为堆；构造子树之后判断子树的子树是不是满足堆的定义（例如构造L(1)子树后，判断L(2)L(3)是不是符合堆的定义；构造L(2)之后判断L(4)是不是满足。L(i)中i为完全二叉树的结点序号）<img src="/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/1%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210904112101069.png" alt="image-20210904112101069"></li>
<li>输出堆顶：将堆顶元素与最后一个元素交换，再构造堆<img src="/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/1%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210904112224830.png" alt="image-20210904112224830"></li>
<li>插入：<img src="/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/1%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210904112701053.png" alt="image-20210904112701053"></li>
</ul>
</li>
<li>空间复杂度$O(1)$</li>
<li>建堆时间$O(n)$，n-1次向下调整的操作时间复杂度为$O(h)$，最好、最坏、平均时间复杂度$O(nlog_2 n)$</li>
<li>不稳定</li>
<li>适用：关键字比较多的情况，<img src="/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/1%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210904112739692.png" alt="image-20210904112739692"></li>
</ul>
</li>
</ol>
<h3 id="归并排序与基数排序"><a href="#归并排序与基数排序" class="headerlink" title="归并排序与基数排序"></a>归并排序与基数排序</h3><ol>
<li>归并排序<ol>
<li>思想：不断地合并</li>
<li><img src="/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/1%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210904113438258.png" alt="image-20210904113438258"></li>
<li>空间复杂度$O(n)$，需要辅助数组</li>
<li>每趟归并时间复杂度$O(n)$，需要进行$\lceil log_2n\rceil$趟归并，所以总的时间复杂度$O(nlog_2 n)$</li>
<li>2路归并排序稳定</li>
</ol>
</li>
<li>基数排序<ol>
<li>思想：基于关键字各位的大小进行排序。奇数：每位的取值个数（0~9）</li>
<li>流程：分配+收集</li>
<li>分类<ol>
<li>最高位优先（MSD）</li>
<li>最低位优先（LSD）：先排序个位，在十位，再百位…<ul>
<li><img src="/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/1%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210904114302926.png" alt="image-20210904114302926"><img src="/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/1%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210904114317387.png" alt="image-20210904114317387"></li>
<li>空间复杂度$O(r)$，r为队列个数</li>
<li>最好、最坏、平均时间复杂度$O(d(n+r))$，$d$是趟数</li>
<li>稳定</li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="内部排序算法比较与应用"><a href="#内部排序算法比较与应用" class="headerlink" title="内部排序算法比较与应用"></a>内部排序算法比较与应用</h3><p><img src="/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/1%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210904143942478.png" alt="image-20210904143942478"></p>
<ol>
<li>n较小，则可以选取直接插入排序或简单选择排序</li>
<li>中等n（$n\le 1000$），可以选择希尔排序</li>
<li>文件的初始状态已经基本有序，则选用直接插入排序或者冒泡排序</li>
<li>n较大，赢采用快速排序、堆排序、2路归并排序（稳定）</li>
<li>n很大，关键字位数少可以分解的时候，采用基数排序比较好</li>
<li>记录本身信息量比较大，为了避免耗费大量时间异动记录，可用链表作为存储结构。</li>
</ol>
<h3 id="外部排序"><a href="#外部排序" class="headerlink" title="外部排序"></a>外部排序</h3><p>外部排序时间=内部排序时间+外存信息读写的事件+内部归并所需要的事件</p>
<p>置换选择排序用作生成初始归并段的方法</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://naixil.github.io/2021/09/01/3Windows/W-1-Windows%E4%B8%8BSSH%E7%99%BB%E5%BD%95%E9%98%BF%E9%87%8C%E4%BA%91ECSlinux/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Li Xian">
      <meta itemprop="description" content="与遗忘作斗争">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LiXian's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/09/01/3Windows/W-1-Windows%E4%B8%8BSSH%E7%99%BB%E5%BD%95%E9%98%BF%E9%87%8C%E4%BA%91ECSlinux/" class="post-title-link" itemprop="url">Windows-1-Windows下SSH登录阿里云ECSlinux.md</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-09-01 11:23:40" itemprop="dateCreated datePublished" datetime="2021-09-01T11:23:40+08:00">2021-09-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-09-02 15:42:50" itemprop="dateModified" datetime="2021-09-02T15:42:50+08:00">2021-09-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Windows/" itemprop="url" rel="index"><span itemprop="name">Windows</span></a>
                </span>
            </span>

          
            <span id="/2021/09/01/3Windows/W-1-Windows%E4%B8%8BSSH%E7%99%BB%E5%BD%95%E9%98%BF%E9%87%8C%E4%BA%91ECSlinux/" class="post-meta-item leancloud_visitors" data-flag-title="Windows-1-Windows下SSH登录阿里云ECSlinux.md" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/09/01/3Windows/W-1-Windows%E4%B8%8BSSH%E7%99%BB%E5%BD%95%E9%98%BF%E9%87%8C%E4%BA%91ECSlinux/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/09/01/3Windows/W-1-Windows%E4%B8%8BSSH%E7%99%BB%E5%BD%95%E9%98%BF%E9%87%8C%E4%BA%91ECSlinux/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ul>
<li><a href="#1-%E6%9C%AC%E6%96%87%E6%91%98%E8%A6%81%E5%8F%8A%E8%AF%B4%E6%98%8E">1 本文摘要及说明</a></li>
<li><a href="#2-windows%E9%85%8D%E7%BD%AE%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95%E7%9A%84%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E6%96%B9%E6%B3%95">2 Windows配置远程登录的几种常见方法</a><ul>
<li><a href="#21-windows-powershell-%E6%96%B9%E5%BC%8F">2.1 Windows PowerShell 方式</a><ul>
<li><a href="#211-%E6%A3%80%E6%9F%A5">2.1.1 检查</a></li>
<li><a href="#212-%E7%94%9F%E6%88%90%E5%AF%86%E9%92%A5">2.1.2 生成密钥</a></li>
<li><a href="#213-%E6%96%B0%E5%BB%BAconfig%E6%96%87%E4%BB%B6">2.1.3 新建config文件</a></li>
<li><a href="#214-%E8%BF%9E%E6%8E%A5%E8%BF%9C%E7%A8%8Becs%E5%AE%9E%E4%BE%8B">2.1.4 连接远程ECS实例</a></li>
</ul>
</li>
<li><a href="#22-git-bash-%E6%96%B9%E5%BC%8F">2.2 Git Bash 方式</a></li>
<li><a href="#23-vscode%E6%8F%92%E4%BB%B6remote-ssh%E6%96%B9%E5%BC%8F">2.3 VSCode插件（Remote-SSH）方式</a><ul>
<li><a href="#231-%E5%AE%89%E8%A3%85%E6%8F%92%E4%BB%B6">2.3.1 安装插件：</a></li>
<li><a href="#232-%E8%BF%9E%E6%8E%A5">2.3.2 连接</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE">参考文献</a></li>
</ul>
<h1 id="1-本文摘要及说明"><a href="#1-本文摘要及说明" class="headerlink" title="1 本文摘要及说明"></a>1 本文摘要及说明</h1><p>小白写的小白向教程，错误之处还请指正。</p>
<p>记录自己Windows采用SSH方式远程登录阿里云ECS虚拟机的配置过程记录及踩的坑。</p>
<p>前提：</p>
<ul>
<li>阿里云ECS实例需要时开启状态</li>
<li>阿里云ECS实例中“本实例安全组”的“内网入方向全部规则”中要保持22/22端口的开启。（其实这个端口默认是开启的，笔者前段时间进行过设置，导致该端口并未开启，从而受到阻碍，故提出此处注意的点。）</li>
</ul>
<p><img src="/2021/09/01/3Windows/W-1-Windows%E4%B8%8BSSH%E7%99%BB%E5%BD%95%E9%98%BF%E9%87%8C%E4%BA%91ECSlinux/2020-08-14-23-48-35.png"></p>
<h1 id="2-Windows配置远程登录的几种常见方法"><a href="#2-Windows配置远程登录的几种常见方法" class="headerlink" title="2 Windows配置远程登录的几种常见方法"></a>2 Windows配置远程登录的几种常见方法</h1><h2 id="2-1-Windows-PowerShell-方式"><a href="#2-1-Windows-PowerShell-方式" class="headerlink" title="2.1 Windows PowerShell 方式"></a>2.1 Windows PowerShell 方式</h2><h3 id="2-1-1-检查"><a href="#2-1-1-检查" class="headerlink" title="2.1.1 检查"></a>2.1.1 检查</h3><p>首先检查自己是不是系统已经安装了SSH，笔者电脑Win 10版本是2004，发现已经安装了SSH，若读者电脑未安装，则可通过<a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/windows-server/administration/openssh/openssh_install_firstuse">此处</a>查看如何安装<br><img src="/2021/09/01/3Windows/W-1-Windows%E4%B8%8BSSH%E7%99%BB%E5%BD%95%E9%98%BF%E9%87%8C%E4%BA%91ECSlinux/2020-08-14-21-45-48.png"></p>
<h3 id="2-1-2-生成密钥"><a href="#2-1-2-生成密钥" class="headerlink" title="2.1.2 生成密钥"></a>2.1.2 生成密钥</h3><p>输入命令<code>ssh-keygen</code>生成公私钥，这一步一路回车即可。<br><img src="/2021/09/01/3Windows/W-1-Windows%E4%B8%8BSSH%E7%99%BB%E5%BD%95%E9%98%BF%E9%87%8C%E4%BA%91ECSlinux/2020-08-14-23-41-51.png"></p>
<p>由于笔者已经生成过，所以有提示是否覆写，正常情况下一路回车即可。啥都不用填写，直接回车。</p>
<h3 id="2-1-3-新建config文件"><a href="#2-1-3-新建config文件" class="headerlink" title="2.1.3 新建config文件"></a>2.1.3 新建config文件</h3><p>打开密钥存储的路径文件夹<code>C:\User\lihua/.ssh</code>（名字以lihua为例）新建一个config文件（文件无后缀名），其内容如下所示：</p>
<pre><code>Host root
  HostName xx.xx.xxx.xxx
  User xxxx
  Port xx
  IdentityFile ~/.ssh/id_rsa
</code></pre>
<p>说明：  </p>
<ul>
<li><p>Host: 这个地方随便写，笔者这写的<code>root</code>，故意与$User$不一致，是为了与GitBash方式区分开。</p>
</li>
<li><p>HostName: 此处填写阿里云ECS实例的公网IP地址，如下图：<br><img src="/2021/09/01/3Windows/W-1-Windows%E4%B8%8BSSH%E7%99%BB%E5%BD%95%E9%98%BF%E9%87%8C%E4%BA%91ECSlinux/2020-08-14-23-45-31.png"></p>
</li>
<li><p>User: 这是阿里云ECS实例的用户名，有的教程可能写的是root但是笔者试了并不能成功，可能需要进行别的设置才行吧。笔者这里经过反复验证发现是虚拟机的账户名才成功连接。比如：lihua, wanglei 这种当初设置的账户名称</p>
</li>
<li><p>Port: 端口号，笔者这里是22</p>
</li>
<li><p>最后一行<code>IdentityFile</code>照抄即可</p>
</li>
</ul>
<p>最后查看自己windows电脑的文件路径，应该如下所示（know_hosts可以没有，这个应该是后期连接服务器才生成的，确保前三个文件是有的话即可）<br><img src="/2021/09/01/3Windows/W-1-Windows%E4%B8%8BSSH%E7%99%BB%E5%BD%95%E9%98%BF%E9%87%8C%E4%BA%91ECSlinux/2020-08-14-23-30-33.png"></p>
<h3 id="2-1-4-连接远程ECS实例"><a href="#2-1-4-连接远程ECS实例" class="headerlink" title="2.1.4 连接远程ECS实例"></a>2.1.4 连接远程ECS实例</h3><p>打开PowerShell并进入到<code>C:\User\lihua/.ssh</code>文件下输入如下命令</p>
<pre><code>ssh lihua@xx.xx.xxx.xxx -p 22
</code></pre>
<p>再输入密码（如果读者的ECS安装了图形化界面的话，密码是图形化界面登录的密码，而不是ECS自带VNC远程连接的密码。）</p>
<p><img src="/2021/09/01/3Windows/W-1-Windows%E4%B8%8BSSH%E7%99%BB%E5%BD%95%E9%98%BF%E9%87%8C%E4%BA%91ECSlinux/2020-08-15-00-04-58.png"></p>
<p>登录成功之后应该是这样的，同时邮件还会受到阿里云的提示：</p>
<p><img src="/2021/09/01/3Windows/W-1-Windows%E4%B8%8BSSH%E7%99%BB%E5%BD%95%E9%98%BF%E9%87%8C%E4%BA%91ECSlinux/2020-08-15-00-02-49.png"><br><img src="/2021/09/01/3Windows/W-1-Windows%E4%B8%8BSSH%E7%99%BB%E5%BD%95%E9%98%BF%E9%87%8C%E4%BA%91ECSlinux/2020-08-15-00-08-00.png"></p>
<h2 id="2-2-Git-Bash-方式"><a href="#2-2-Git-Bash-方式" class="headerlink" title="2.2 Git Bash 方式"></a>2.2 Git Bash 方式</h2><p>前三步和上一节一样，只有连接上有一处需要注意的地方。打开<code>C:\User\lihua/.ssh</code>直接Git Bash Here：</p>
<p><img src="/2021/09/01/3Windows/W-1-Windows%E4%B8%8BSSH%E7%99%BB%E5%BD%95%E9%98%BF%E9%87%8C%E4%BA%91ECSlinux/2020-08-15-00-16-25.png"></p>
<p>然后输入箭头所指的内容：</p>
<p><img src="/2021/09/01/3Windows/W-1-Windows%E4%B8%8BSSH%E7%99%BB%E5%BD%95%E9%98%BF%E9%87%8C%E4%BA%91ECSlinux/2020-08-15-00-17-50.png"></p>
<p>可以发现，<strong>这里是<code>ssh root</code>，root是$config$文件里的Host，而不是User</strong>，此处是需要注意的。</p>
<h2 id="2-3-VSCode插件（Remote-SSH）方式"><a href="#2-3-VSCode插件（Remote-SSH）方式" class="headerlink" title="2.3 VSCode插件（Remote-SSH）方式"></a>2.3 VSCode插件（Remote-SSH）方式</h2><h3 id="2-3-1-安装插件："><a href="#2-3-1-安装插件：" class="headerlink" title="2.3.1 安装插件："></a>2.3.1 安装插件：</h3><p><img src="/2021/09/01/3Windows/W-1-Windows%E4%B8%8BSSH%E7%99%BB%E5%BD%95%E9%98%BF%E9%87%8C%E4%BA%91ECSlinux/2020-08-15-00-21-01.png"></p>
<h3 id="2-3-2-连接"><a href="#2-3-2-连接" class="headerlink" title="2.3.2 连接"></a>2.3.2 连接</h3><ol>
<li>点击+号</li>
</ol>
<p><img src="/2021/09/01/3Windows/W-1-Windows%E4%B8%8BSSH%E7%99%BB%E5%BD%95%E9%98%BF%E9%87%8C%E4%BA%91ECSlinux/2020-08-15-00-30-03.png"></p>
<ol start="2">
<li><p>输入<code>ssh lihua@xx.xx.xxx.xxx -p 22</code></p>
</li>
<li><p>右键连接：</p>
</li>
</ol>
<p><img src="/2021/09/01/3Windows/W-1-Windows%E4%B8%8BSSH%E7%99%BB%E5%BD%95%E9%98%BF%E9%87%8C%E4%BA%91ECSlinux/2020-08-15-00-31-58.png">  </p>
<p>然后：</p>
<p><img src="/2021/09/01/3Windows/W-1-Windows%E4%B8%8BSSH%E7%99%BB%E5%BD%95%E9%98%BF%E9%87%8C%E4%BA%91ECSlinux/2020-08-15-00-32-36.png"></p>
<p>再然后：</p>
<p><img src="/2021/09/01/3Windows/W-1-Windows%E4%B8%8BSSH%E7%99%BB%E5%BD%95%E9%98%BF%E9%87%8C%E4%BA%91ECSlinux/2020-08-15-00-33-18.png"></p>
<p>左下角这样就说明成功连接了：</p>
<p><img src="/2021/09/01/3Windows/W-1-Windows%E4%B8%8BSSH%E7%99%BB%E5%BD%95%E9%98%BF%E9%87%8C%E4%BA%91ECSlinux/2020-08-15-00-36-52.png"></p>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><blockquote>
<p>[1] <a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/windows-server/administration/openssh/openssh_install_firstuse">https://docs.microsoft.com/zh-cn/windows-server/administration/openssh/openssh_install_firstuse</a><br>[2] <a target="_blank" rel="noopener" href="https://code.visualstudio.com/docs/remote/ssh">https://code.visualstudio.com/docs/remote/ssh</a><br>[3] <a target="_blank" rel="noopener" href="https://www.cnblogs.com/chenzhaoyu/p/9898679.html">https://www.cnblogs.com/chenzhaoyu/p/9898679.html</a><br>[4] <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/68577071">https://zhuanlan.zhihu.com/p/68577071</a>  </p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://naixil.github.io/2021/09/01/3Windows/W-3-Hyper-V%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%98%A0%E5%B0%84%E7%AB%AF%E5%8F%A3%E5%88%B0%E5%AE%BF%E4%B8%BB%E6%9C%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Li Xian">
      <meta itemprop="description" content="与遗忘作斗争">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LiXian's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/09/01/3Windows/W-3-Hyper-V%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%98%A0%E5%B0%84%E7%AB%AF%E5%8F%A3%E5%88%B0%E5%AE%BF%E4%B8%BB%E6%9C%BA/" class="post-title-link" itemprop="url">Windows-3-Hyper-V虚拟机映射端口到宿主机</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-09-01 11:23:40 / 修改时间：21:07:57" itemprop="dateCreated datePublished" datetime="2021-09-01T11:23:40+08:00">2021-09-01</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Windows/" itemprop="url" rel="index"><span itemprop="name">Windows</span></a>
                </span>
            </span>

          
            <span id="/2021/09/01/3Windows/W-3-Hyper-V%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%98%A0%E5%B0%84%E7%AB%AF%E5%8F%A3%E5%88%B0%E5%AE%BF%E4%B8%BB%E6%9C%BA/" class="post-meta-item leancloud_visitors" data-flag-title="Windows-3-Hyper-V虚拟机映射端口到宿主机" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/09/01/3Windows/W-3-Hyper-V%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%98%A0%E5%B0%84%E7%AB%AF%E5%8F%A3%E5%88%B0%E5%AE%BF%E4%B8%BB%E6%9C%BA/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/09/01/3Windows/W-3-Hyper-V%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%98%A0%E5%B0%84%E7%AB%AF%E5%8F%A3%E5%88%B0%E5%AE%BF%E4%B8%BB%E6%9C%BA/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>243</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>映射虚拟机端口5000到宿主机的6000</p>
<p>netsh interface portproxy add v4tov4 listenport=6000 connectport=5000 connectaddress=101.7.186.201(虚拟机IP)</p>
<p>删除端口映射：</p>
<p>netsh interface portproxy delete v4tov4 listenport=6000</p>
<p>显示端口：</p>
<p>netsh interface portproxy show all</p>
<p>netsh interface portproxy show v4tov4</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://naixil.github.io/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/4%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Li Xian">
      <meta itemprop="description" content="与遗忘作斗争">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LiXian's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/4%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/" class="post-title-link" itemprop="url">软件工程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-09-01 00:00:01" itemprop="dateCreated datePublished" datetime="2021-09-01T00:00:01+08:00">2021-09-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-09-26 13:54:03" itemprop="dateModified" datetime="2021-09-26T13:54:03+08:00">2021-09-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/" itemprop="url" rel="index"><span itemprop="name">计算机基础知识总结</span></a>
                </span>
            </span>

          
            <span id="/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/4%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/" class="post-meta-item leancloud_visitors" data-flag-title="软件工程" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/4%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/4%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>690</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="重点摘录"><a href="#重点摘录" class="headerlink" title="重点摘录"></a>重点摘录</h1><ol>
<li>软件生存周期<ol>
<li>计划时期<ol>
<li>问题定义</li>
<li>可行性研究<ol>
<li>经济、技术、操作、法律可行性</li>
</ol>
</li>
</ol>
</li>
<li>开发时期<ol>
<li>需求分析<ol>
<li>面向功能分解方法：分为功能、子功能、接口<ol>
<li>体现”自顶向下、逐步求精“思想</li>
</ol>
</li>
<li>结构化分析方法：数据流图和数据字典构成系统的逻辑模型</li>
<li>信息建模方法：实体联系图</li>
<li>面向对象分析方法：实体联系图结合面向对象</li>
</ol>
</li>
<li>概要设计（怎么做）<ol>
<li>总体/概要设计：高内聚、低耦合</li>
<li>耦合：模块之间联系程度的度量<ol>
<li>无直接耦合</li>
<li>数据耦合：有调用关系，传递的信息是数据</li>
<li>标记耦合：传递的是数据结构</li>
<li>控制耦合：传递的信息控制另一个模块的功能</li>
<li>公共环境耦合：共用一个数据环境</li>
<li>内容耦合：模块访问另一个模块的内部数据（避免使用）</li>
</ol>
</li>
<li>内聚：模块内各个元素的关系<ol>
<li>偶然内聚：元素之间没有意义上的联系</li>
<li>逻辑内聚：逻辑上相同或相似的一类任务放在同一个模块中，每次被调用，由传送给模块的参数来确定该模块应完成的某一功能</li>
<li>时间内聚：通知执行</li>
<li>通信内聚：使用相同输入或产生相同输出</li>
<li>顺序内聚</li>
<li>功能内聚：属于一个整体，完成一个单一功能</li>
</ol>
</li>
</ol>
</li>
<li>详细设计（怎么实现）</li>
<li>编码</li>
<li>测试（单元测试、集成测试、验收测试）<ol>
<li>分类：<ol>
<li>动态测试：运行代码</li>
<li>静态测试：不运行代码检查错误</li>
<li>黑盒测试/数据驱动：不考虑程序内部结构和处理过程<ol>
<li>等价类划分法：<ol>
<li>有效等价类：满足程序输入的规范说明、合理、有意义的输入数据</li>
<li>无效等价类：完全不满足程序输入的规范说明、不合理、无意义的输入数据</li>
</ol>
</li>
<li>边界值分析法：</li>
<li>错误推测法（依据经验、直觉）</li>
<li>因果图法：考虑输入的各种组合</li>
</ol>
</li>
<li>白盒测试/逻辑驱动：了解程序的内部结构和处理过程<ol>
<li>逻辑覆盖</li>
<li>循环覆盖</li>
<li>基本路径测试</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>运行时期</li>
</ol>
</li>
<li>软件开发模型：<ol>
<li>瀑布模型</li>
<li>快速原型模型</li>
<li>增量模型</li>
<li>螺旋模型</li>
<li>喷泉模型</li>
<li>基于构件的开发模型</li>
<li>统一过程模型</li>
<li>基于形式化的开发模型</li>
</ol>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://naixil.github.io/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/5EPI%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Li Xian">
      <meta itemprop="description" content="与遗忘作斗争">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LiXian's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/5EPI%E6%80%BB%E7%BB%93/" class="post-title-link" itemprop="url">EPI</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-09-01 00:00:01" itemprop="dateCreated datePublished" datetime="2021-09-01T00:00:01+08:00">2021-09-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-09-02 10:59:11" itemprop="dateModified" datetime="2021-09-02T10:59:11+08:00">2021-09-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/" itemprop="url" rel="index"><span itemprop="name">计算机基础知识总结</span></a>
                </span>
            </span>

          
            <span id="/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/5EPI%E6%80%BB%E7%BB%93/" class="post-meta-item leancloud_visitors" data-flag-title="EPI" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/5EPI%E6%80%BB%E7%BB%93/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/5EPI%E6%80%BB%E7%BB%93/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="逻辑判断（判断5、6、7、8，9h）"><a href="#逻辑判断（判断5、6、7、8，9h）" class="headerlink" title="逻辑判断（判断5、6、7、8，9h）"></a>逻辑判断（判断5、6、7、8，9h）</h1><h2 id="翻译推理"><a href="#翻译推理" class="headerlink" title="翻译推理"></a>翻译推理</h2><ul>
<li><p>要素</p>
<ul>
<li>前推后<ul>
<li>若……则……；只要……就……；所有……都……；为了……一定（必须）……；……是……的充分条件<ul>
<li>如果想要取得好成绩，就必须减少玩耍时间 <u>好成绩→少玩耍</u><ul>
<li>取得好成绩 肯前</li>
<li>没取得好成绩 否前</li>
<li>减少玩耍时间 肯后</li>
<li>增加玩耍时间 否后</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>后推前<ul>
<li>只有……，才……；不……，不……<ul>
<li>人无精神则不立 <u>立$\rightarrow$精神</u></li>
</ul>
</li>
<li>除非 A 否则不 B：B→A；除非 A 否则 B：-B→A<ul>
<li>除非天地合，否则我不会与君绝</li>
<li>除非交房租，否则搬出去。不搬出去$\rightarrow$交房租</li>
</ul>
</li>
<li>谁必不可少，谁在箭头后<ul>
<li>…是…的基础/假设/前提/关键/必要/必不可少条件</li>
</ul>
</li>
<li>A的充分条件是B。B$\rightarrow$A</li>
<li>A的必要条件是B。A$\rightarrow$B</li>
</ul>
</li>
</ul>
</li>
<li><p>规则：“逆否等价”</p>
<ul>
<li>$A\rightarrow B=-B\rightarrow -A$</li>
<li><strong>肯前必肯后，否后必否前</strong>；否前肯后不知道</li>
<li>注意：<ol>
<li>选项与题干无关，就不选，如“坚持锻炼→风险降低”，选项“是否坚持锻炼，直接决定了阿尔茨海默症等神经退行性疾病的发病风险能降低”就不选</li>
<li>递推关系可传递<ul>
<li>1.“A→B”和“B→C”，可以写为“A→B→C”。<br>2.“A→B”和“-A→C”，后者逆否为“-C→A”，与前者串联为“-C→A→B”。</li>
<li>3.“A→B”和“C→-B”，后者逆否为“B→-C”，与前者串联为“A→B→-C”。</li>
<li>4.“A→B”和“A→C”不能串联。</li>
<li>5.“A→B→C”可以写为“A→C”，也可以写为“-C→-B→-A”；“A→B→-C”<br>可以写为“C→-B→-A”，均可以随意变换。</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
<li><p>要素</p>
<ul>
<li>且<ul>
<li>和、既……又……、不仅……而且……、……但是……</li>
</ul>
</li>
<li>或<ul>
<li>或者、或者…或者…、至少一个<strong>（两个也行）</strong><ul>
<li><strong>否1$\rightarrow$1</strong><ul>
<li>我不看篮球或不看足球。看篮球$\rightarrow$不看足球</li>
</ul>
</li>
</ul>
</li>
<li><u>AB至多一个。-A或-B</u></li>
</ul>
</li>
<li>德摩根定律<ul>
<li>-（A 且 B）=-A 或-B</li>
<li> -（A 或 B）=-A 且-B</li>
<li>“-”进去，“且”“或”互变<ul>
<li>-（方便面且大盘鸡）=-方便面或-大盘鸡</li>
<li>-（咖啡因或泡枸杞）=-咖啡因且-泡枸杞</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<img src="/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/5EPI%E6%80%BB%E7%BB%93/image-20210823150123515.png" alt="image-20210823150123515" style="zoom: 50%;">

<ul>
<li>要素<ul>
<li>提问：以下哪项与题干中推理形式/结构相同？</li>
<li>把名词换成字母<ul>
<li><img src="/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/5EPI%E6%80%BB%E7%BB%93/image-20210823151618623.png" alt="image-20210823151618623" style="zoom: 50%;"></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="组合排列"><a href="#组合排列" class="headerlink" title="组合排列"></a>组合排列</h2><ul>
<li>题型特征：题干中给出一组对象和相关信息，要求把对象和信息进行匹配</li>
<li>方法<ul>
<li>排除法<ul>
<li>何时用：题干信息确定</li>
<li>**首要确定谁不是谁 **<ul>
<li>比大小的题目，极值很重要。（谁最大，谁最小）</li>
</ul>
</li>
</ul>
</li>
<li>代入法<ul>
<li>假设选项正确，代入题干<ul>
<li><img src="/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/5EPI%E6%80%BB%E7%BB%93/image-20210823161100333.png" alt="image-20210823161100333" style="zoom:67%;"></li>
</ul>
</li>
<li>题干有“补充/添加以下哪项可以退出”，尝试代入</li>
<li><strong>设问中有可能、不可能，考虑代入</strong><ul>
<li>隧道排序问题</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li> 推理技巧</li>
</ul>
<ol>
<li>优先关注出现次数最多信息<ul>
<li><img src="/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/5EPI%E6%80%BB%E7%BB%93/image-20210823162454639.png" alt="image-20210823162454639" style="zoom: 50%;">
- <img src="/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/5EPI%E6%80%BB%E7%BB%93/image-20210823162532752.png" alt="image-20210823162532752" style="zoom: 50%;"></li>
<li><img src="/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/5EPI%E6%80%BB%E7%BB%93/image-20210823163459924.png" alt="image-20210823163459924" style="zoom: 50%;">
- 根据题干，只有一个人考上了研究生，只有一个人说的正确且说的正确的人考上了研究生，可以知道，研究生只有一个且说的话正确；从“研究生”出现的地方入手，G说的话，必是假，因为如果G对，那么G是研究生，又因为研究生只有一个，所以G假话；可以推知H肯定没考上研究生，也就是H说了假话，也就是J是公务员，所以选D。</li>
</ul>
</li>
<li>符号“&gt;”、“&lt;”。往往涉及年龄、成绩、身高、收入等大小比较</li>
<li>对象和信息比较多的时候，列表格；排序题考虑间隔</li>
</ol>
<h2 id="逻辑论证"><a href="#逻辑论证" class="headerlink" title="逻辑论证"></a>逻辑论证</h2><ol>
<li>论点提示词：所以，结论是，这表明/说明/意味着，由此推出/可知，据此<br>认为</li>
<li>论据提示词：由于、因为、鉴于、根据</li>
<li>论据常见形式：原因、数据、事例、实验或调查内容等</li>
</ol>
<ul>
<li>削弱题型：反对<ul>
<li>题型特征：提问“削弱”、“质疑”、“反驳”、“否定”</li>
<li>削弱方式：论点与论据一致，优先考虑否定论点；论点与论据不一致、没有否定论点的选项、提问方式为削弱论证的时候，优先考虑拆桥。<ul>
<li>否定论点<ul>
<li>选项特征：与论点表述的意思相反 </li>
<li>解题步骤<ol>
<li>找出论点</li>
<li>想出与论点意思相反的表述</li>
<li>寻找对应选项</li>
</ol>
</li>
<li>例子<ul>
<li><img src="/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/5EPI%E6%80%BB%E7%BB%93/image-20210823195517523.png" alt="image-20210823195517523" style="zoom:50%;">
- 但是之前的不看，只有论点，否定论点：养老机构的噪音不影响居民生活。对比选项，A中心在位置，B中心在不了解，D中心在办养老机构之前，都无关</li>
<li><img src="/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/5EPI%E6%80%BB%E7%BB%93/image-20210823200857527.png" alt="image-20210823200857527" style="zoom:50%;"></li>
<li><img src="/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/5EPI%E6%80%BB%E7%BB%93/image-20210823212131897.png" alt="image-20210823212131897" style="zoom:50%;"></li>
</ul>
</li>
<li>常见的论点特殊形式<ul>
<li>论点为“不是 A，是 C 导致 B”：甲：A 导致 B;乙：不是 A，是 C 导致 B<ul>
<li>选项就找常考削弱乙——A 导致 C<ul>
<li><img src="/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/5EPI%E6%80%BB%E7%BB%93/image-20210823212836980.png" alt="image-20210823212836980"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>拆桥<ul>
<li>题型特征说论点与论据之间没有必然的联系。<ul>
<li>特殊考法：论点为某物质比较好，论据为物质中的某些元素好<ul>
<li>解题方法：元素含量少，没啥作用</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>否定论据<ul>
<li><img src="/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/5EPI%E6%80%BB%E7%BB%93/image-20210823223029536.png" alt="image-20210823223029536"></li>
</ul>
</li>
<li>因果类<ul>
<li>什么是因果论证？<ul>
<li><strong>1.论点包含因果关系</strong><ul>
<li>……是……的原因、</li>
<li>……导致/使得/有助于……</li>
<li>……增加/降低/加强/减轻……<ul>
<li>例：研究人员认为，“缺觉”是导致第二天没有精神的原因</li>
<li>例 ：有研究小组调查显示，在封闭环境中入睡的人更容易频繁醒来，而且自我感觉睡眠质量不佳。因此，有人认为，就寝时关闭门窗将会降低睡眠质量</li>
</ul>
</li>
</ul>
</li>
<li>因果倒置削弱：原因与结果说反</li>
<li>他因削弱：承认结果，同一个主体存在两种及以上可能的原因；如果论点是其中一种原因，则可以用另一种原因进行削弱。<ul>
<li>他因的特点：与论点是同一个主体、同一时间、不同原因<ul>
<li><img src="/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/5EPI%E6%80%BB%E7%BB%93/image-20210823234229146.png" alt="image-20210823234229146"></li>
</ul>
</li>
<li></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>加强提醒：赞同</li>
</ul>
<h2 id="日常结论"><a href="#日常结论" class="headerlink" title="日常结论"></a>日常结论</h2><h2 id="原因解释"><a href="#原因解释" class="headerlink" title="原因解释"></a>原因解释</h2><h1 id="定义判断-判断4，2h"><a href="#定义判断-判断4，2h" class="headerlink" title="定义判断(判断4，2h)"></a>定义判断(判断4，2h)</h1><h1 id="图形推理-判断1、2，5h"><a href="#图形推理-判断1、2，5h" class="headerlink" title="图形推理(判断1、2，5h)"></a>图形推理(判断1、2，5h)</h1><h1 id="类比推理-判断3，2h"><a href="#类比推理-判断3，2h" class="headerlink" title="类比推理(判断3，2h)"></a>类比推理(判断3，2h)</h1><h1 id="言语理解与表达-18h"><a href="#言语理解与表达-18h" class="headerlink" title="言语理解与表达(18h)"></a>言语理解与表达(18h)</h1><h1 id="数字推理"><a href="#数字推理" class="headerlink" title="数字推理"></a>数字推理</h1><h1 id="数字运算-数量1-4，12h"><a href="#数字运算-数量1-4，12h" class="headerlink" title="数字运算(数量1-4，12h)"></a>数字运算(数量1-4，12h)</h1><h1 id="资料分析-14h"><a href="#资料分析-14h" class="headerlink" title="资料分析(14h)"></a>资料分析(14h)</h1><h1 id="思维策略"><a href="#思维策略" class="headerlink" title="思维策略"></a>思维策略</h1>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://naixil.github.io/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/2%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Li Xian">
      <meta itemprop="description" content="与遗忘作斗争">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LiXian's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/2%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" class="post-title-link" itemprop="url">计算机网络</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-09-01 00:00:01" itemprop="dateCreated datePublished" datetime="2021-09-01T00:00:01+08:00">2021-09-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-09-26 11:47:28" itemprop="dateModified" datetime="2021-09-26T11:47:28+08:00">2021-09-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/" itemprop="url" rel="index"><span itemprop="name">计算机基础知识总结</span></a>
                </span>
            </span>

          
            <span id="/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/2%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" class="post-meta-item leancloud_visitors" data-flag-title="计算机网络" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/2%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/2%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>9.4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>9 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="计算机网络（第7版）"><a href="#计算机网络（第7版）" class="headerlink" title="计算机网络（第7版）"></a>计算机网络（第7版）</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="互联网的组成"><a href="#互联网的组成" class="headerlink" title="互联网的组成"></a>互联网的组成</h3><ol>
<li>边缘部分（用户直接使用的）<ul>
<li>C/S，客户-服务器方式</li>
<li>P2P，对等连接方式</li>
</ul>
</li>
<li>核心部分（提供连通性和交换的，服务于边缘）<ul>
<li>路由器实现<strong>分组交换</strong>功能，采用存储转发技术<ul>
<li>优点：高效（动态分配带宽）、灵活（对分组独立选择路由）、迅速（不建立连接就可以发送分组）、可靠（靠协议和分组交换网实现）</li>
<li>缺点：分组交换造成时延；分组控制信息造成时延。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="计算机网络的类别"><a href="#计算机网络的类别" class="headerlink" title="计算机网络的类别"></a>计算机网络的类别</h3><ol>
<li>按照网络的作用范围<ul>
<li>广域网WAN,Wide，采用交换技术</li>
<li>城域网MAN,Metropolitan</li>
<li>局域网LAN,Local，采用广播技术</li>
<li>个人局域网PAN,Personal</li>
</ul>
</li>
<li>按照网络的使用者<ul>
<li>公用网</li>
<li>专用网</li>
</ul>
</li>
<li>接入网（AN）</li>
</ol>
<h3 id="计算机网络的性能指标"><a href="#计算机网络的性能指标" class="headerlink" title="计算机网络的性能指标"></a>计算机网络的性能指标</h3><ol>
<li>速率：bit/s</li>
<li>带宽：传输的最高数据率，bit/s</li>
<li>吞吐量</li>
<li>时延<ol>
<li>发送时延：数据帧长度/发送速率</li>
<li>传播时延：信道长度/光速</li>
<li>处理时延：分析分组的首部、提取数据、差错检验</li>
<li>排队时延：在路由器中的排队时间</li>
<li>时延带宽积：传播时延*带宽，又称以比特为单位的链路长度</li>
</ol>
</li>
<li>往返时间RRT，Round-Trip-Time。有效数据率=数据长度/(发送时间+RRT)</li>
<li>利用率：信道利用率；网络利用率（全网络信道利用率的加权平均）。利用率增大，时延急速变大</li>
</ol>
<h3 id="计算机网络体系结构（从功能的角度划分）"><a href="#计算机网络体系结构（从功能的角度划分）" class="headerlink" title="计算机网络体系结构（从功能的角度划分）"></a>计算机网络体系结构（从功能的角度划分）</h3><p>开放系统互连基本参考模型OSI/RM（7层），理论上的。事实上是TCP/IP（4层，应用层、运输层、网际层、网络接口层）。</p>
<img src="/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/2%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210824003124298.png" alt="image-20210824003124298" style="zoom:50%;">

<p>OSI模型通信过程：</p>
<img src="/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/2%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210824094024156.png" alt="image-20210824094024156" style="zoom:50%;">

<p>表示层：功能：数据格式变换；数据加密解密；数据压缩与回复</p>
<p>会话层：功能：建立连接</p>
<p>传输层：功能：可靠传输；差错控制；流量控制；复用分用。</p>
<p>网络层：功能：路由选择；流量控制；差错控制；拥塞控制。</p>
<p><strong>五层协议：</strong></p>
<ol>
<li>应用层    <ul>
<li>通过进程间交互完成特定网络应用</li>
<li>协议包括DNS,HTTP,SMTP,FTP</li>
</ul>
</li>
<li>运输层<ul>
<li>负责向两台主机进程间通信提供通用的数据传输服务。</li>
<li>协议包括：传输控制协议(TCP)，面向连接的、可靠的数据传输协议，单位是==报文段==；用户数据报协议(UDP)，无连接的、尽最大努力的数据传输服务，单位是==用户数据报==。</li>
</ul>
</li>
<li>网络层<ul>
<li>为分组交换网上的不同主机提供通信服务</li>
<li>协议IP协议，IPX,ICMP,IGMP,ARP；主要设备是路由器；传输单位是==IP数据报==。</li>
</ul>
</li>
<li>数据链路层：主要设备是交换机，网桥；把数据报组装成==帧==</li>
<li>物理层==：单位是bit==，主要设备是集线器，中继器</li>
</ol>
<p><strong>辨析：</strong></p>
<ul>
<li>可靠性由运输层的TCP协议负责</li>
</ul>
<h2 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h2><h3 id="信道、码元、传输速率"><a href="#信道、码元、传输速率" class="headerlink" title="信道、码元、传输速率"></a>信道、码元、传输速率</h3><ul>
<li>信号<ul>
<li>模拟信号：调制解调器到电话端局</li>
<li>数字信号：用户计算机到调制解调器<ul>
<li>调制：<ul>
<li>基带调制：对基带信号的波形进行变换</li>
<li>带通调制：用载波（carrier）把基带信号的频率范围调高，转换成模拟信号</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>信道<ul>
<li>码元：时间间隔相同的符号表示一个二进制数字，这样的时间间隔内的信号称为二进制码元。</li>
<li>波特率：多少码元/s，单位$ Baud $。有上限，超过则会产生码间串扰，使得信号失真。</li>
<li>传输方式：<ul>
<li>单工</li>
<li>半双工：不能同时发送消息</li>
<li>全双工</li>
</ul>
</li>
<li>码元传输速率<ul>
<li>公式：$ C=Wlog_2(1+S/N) (bit/s) $</li>
<li>影响：<ul>
<li>信道的频率范围</li>
<li>信噪比</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>常用编码方式：<ul>
<li><img src="/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/2%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210824101613775.png" alt="image-20210824101613775" style="zoom: 67%;"></li>
<li>不归零制：正电瓶代表1；负代表0</li>
<li>归零制：正脉冲代表1；负脉冲代表0</li>
<li>曼彻斯特编码：位周期中心的向上跳变代表0；向下跳变代表1</li>
<li>差分曼彻斯特编码：位的开始边界有跳变代表0；没有跳变代表1。每一位的中心都有跳变。</li>
</ul>
</li>
<li>传输介质<ul>
<li>导引型传输媒体：双绞线；同轴电缆；光缆</li>
<li>非导引型传输媒体：<ul>
<li>范围：甚高频（30MHz~300MHz）；特高频（300~3G）；超高频（3G~30G）；极高频（30G~300G）</li>
<li>无线电波：所有方向；穿透能力强，远距离</li>
<li>微波通信（300M~30GHz），常用的是（2~40GHz）。传播方向直线<ul>
<li>地面微波通信</li>
<li>卫星通信<ul>
<li>优点：通信容量大；距离远；覆盖广；广播通信和多址通信</li>
<li>缺点：时延长；受气候影响；误码率高；成本高</li>
</ul>
</li>
</ul>
</li>
<li>红外光、激光：需要转换信号格式为红外光、激光信号</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="信道复用（multiplexing）技术"><a href="#信道复用（multiplexing）技术" class="headerlink" title="信道复用（multiplexing）技术"></a>信道复用（multiplexing）技术</h3><ul>
<li></li>
</ul>
<h2 id="数据链路层（以下王道考研书的目录格式，书太乱）"><a href="#数据链路层（以下王道考研书的目录格式，书太乱）" class="headerlink" title="数据链路层（以下王道考研书的目录格式，书太乱）"></a>数据链路层（以下王道考研书的目录格式，书太乱）</h2><h3 id="数据链路层的功能、介绍"><a href="#数据链路层的功能、介绍" class="headerlink" title="数据链路层的功能、介绍"></a>数据链路层的功能、介绍</h3><ol>
<li>基本概念<ul>
<li>数据链路：物理链路+协议</li>
<li>帧：数据链路层的协议数据单元</li>
</ul>
</li>
<li>数据链路层通信步骤<ol>
<li>网络层的IP数据报添加首部和尾部封装成帧</li>
<li>封装的帧进行发送</li>
<li>检查帧是否出错，提取出来IP数据报发送到网络层</li>
</ol>
</li>
<li>三个基本问题：<ol>
<li>封装成帧<ol>
<li>添加首部( SOH,start of header)和尾部(EOT,end of transmission )用于帧定界</li>
<li>MTU：最大传送单元<img src="/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/2%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210824112746957.png" alt="image-20210824112746957" style="zoom: 80%;"></li>
</ol>
</li>
<li>透明传输：转义SOH,EOT<ul>
<li>方法：字节填充：添加ESC到数据里面的控制字符之前。</li>
</ul>
</li>
</ol>
</li>
</ol>
<h3 id="差错控制"><a href="#差错控制" class="headerlink" title="差错控制"></a>差错控制</h3><ol>
<li>误码率（BER）：传输错误的比特占所有毕业总数的比率。BER与信噪比有关系</li>
<li>传输差错包括：比特差错；帧差错（帧丢失、帧重复、帧失序）</li>
</ol>
<h4 id="检错编码"><a href="#检错编码" class="headerlink" title="检错编码"></a>检错编码</h4><ol>
<li>循环冗余检验（CRC，Cyclic Redundancy Check）<ul>
<li>添加帧检验序列（FCS），就是数据除以一个数之后的余数</li>
<li>优点：可以实现无比特差错的传输，<strong>但并不是可靠传输</strong></li>
<li><img src="/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/2%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210824160224978.png" alt="image-20210824160224978" style="zoom:80%;"></li>
</ul>
</li>
<li>奇、偶校验码，能检测出来奇数个错，不能检测出来偶数个出错</li>
</ol>
<h4 id="纠错编码"><a href="#纠错编码" class="headerlink" title="纠错编码"></a>纠错编码</h4><p>海明码：可以发现双比特错；纠正单比特错。</p>
<ol>
<li>步骤<ol>
<li>根据海明不等式确定效验码的位数：$2^r=k+r+1$,r为冗余信息位数，k为信息位数</li>
<li>确定校验码位置和数据的位置：校验码的位置在$2^n$位置，例如四位校验码位置在：0、1、4、8位置，如下表$P_{1,2,3,4}$的位置</li>
<li>校验码值的求解，令所有要校验的位的异或为0.要校验的位：与校验码位置的二进制位的1所在位置一样的数据（例如，校验码$p_2$的位置的二进制1在倒数第二位，发现$D_{1,3,4,6}$的在倒数第二位，所以$p_1 \oplus D_1 \oplus D_3\oplus D_4\oplus D_6 = 0$，异或：相同为0，相异为1）。<img src="/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/2%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210824161214278.png" alt="image-20210824161214278" style="zoom:67%;"></li>
<li>检错并纠错<ul>
<li><img src="/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/2%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210824162223340.png" alt="image-20210824162223340"></li>
</ul>
</li>
</ol>
</li>
</ol>
<h3 id="流量控制与可靠传输机制"><a href="#流量控制与可靠传输机制" class="headerlink" title="流量控制与可靠传输机制"></a>流量控制与可靠传输机制</h3><h4 id="流量控制、可靠传输与滑动窗口机制"><a href="#流量控制、可靠传输与滑动窗口机制" class="headerlink" title="流量控制、可靠传输与滑动窗口机制"></a>流量控制、可靠传输与滑动窗口机制</h4><ol>
<li>停止-等待流量控制基本原理：发送方发送之后，等待接收方的应答信号，之后才发送下一帧，每次只可以发送一帧</li>
<li>滑动窗口：停止等待：发送窗口=1，接收窗口=1；GBN发送窗口&gt;1，接收窗口=1；SR都大于1。</li>
<li>可靠传输<ul>
<li>数据链路层的可靠传输机制通常使用确认和超时重传两种机制来完成。自动重传请求（ARQ）</li>
<li>PS：可靠传输协议在谢希仁版计算机网络中划归运输层，这是因为现在网络传输质量比较好，抛弃了可靠传输，早期的时候是属于数据链路层的。</li>
</ul>
</li>
</ol>
<h4 id="单帧滑动窗口与停止等待协议"><a href="#单帧滑动窗口与停止等待协议" class="headerlink" title="单帧滑动窗口与停止等待协议"></a>单帧滑动窗口与停止等待协议</h4><ol>
<li>流程<ol>
<li><img src="/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/2%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210824172711599.png" alt="image-20210824172711599" style="zoom: 50%;"></li>
<li><img src="/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/2%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210824172754230.png" alt="image-20210824172754230" style="zoom:50%;"></li>
<li><img src="/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/2%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210824172830473.png" alt="image-20210824172830473" style="zoom:50%;"></li>
</ol>
</li>
<li>缺点：信道利用率低</li>
</ol>
<h4 id="多帧滑动窗口与后退N帧协议（GBN）"><a href="#多帧滑动窗口与后退N帧协议（GBN）" class="headerlink" title="多帧滑动窗口与后退N帧协议（GBN）"></a>多帧滑动窗口与后退N帧协议（GBN）</h4><ol>
<li>原理：可以连续发送帧而不需要确认，<strong>接收方检测到失序的信息帧之后，要求发送方重发最后一个正确接收的信息帧之后所有未被确认的帧</strong>。也就是接收方只能按照顺序接受帧。</li>
<li><strong>累积确认：</strong>接收方为了减少开销，可以接收到N个帧之后发一个，$ACK_n$表示已经收到前$n$个帧；或者自己有数据发过去的时候<strong>稍带确认</strong>。</li>
<li>优点：信道利用率高。</li>
<li>缺点：会丢弃已经送达的正确的帧，导致传送效率不高；滑动窗口长度的选择：如果采用$n$个比特对帧进行编号，那么窗口长度w：$1\le w\le 2^n-1$</li>
</ol>
<h4 id="多帧滑动窗口与选择重传协议（SR）"><a href="#多帧滑动窗口与选择重传协议（SR）" class="headerlink" title="多帧滑动窗口与选择重传协议（SR）"></a>多帧滑动窗口与选择重传协议（SR）</h4><ol>
<li>只重传出现差错的数据帧或计时器超时的数据帧，但是此时必须加大接收窗口（以便接收发送序号不连续但是仍然处在接收窗口中的数据帧），等到所缺失的数据帧到达之后一并交送主机。</li>
<li>特点：接收方有缓存；只重传出错的帧；对数据帧逐一确认，收一个确认一个</li>
<li>窗口长度选择：发送窗口等于接收窗口长度。如果采用$n$个比特对帧进行编号，$W_{Tmax}=W_{Rmax}=2^{n-1}$<ul>
<li><img src="/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/2%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210824221433716.png" alt="image-20210824221433716" style="zoom:50%;"></li>
</ul>
</li>
</ol>
<h3 id="介质访问控制（MAC）"><a href="#介质访问控制（MAC）" class="headerlink" title="介质访问控制（MAC）"></a>介质访问控制（MAC）</h3><ol>
<li>主要任务：隔离信号同一信道的其他节点的信号，协调节点的传输。</li>
</ol>
<img src="/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/2%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210824222121267.png" alt="image-20210824222121267" style="zoom: 67%;">

<h4 id="信道划分MAC（静态分配信道）"><a href="#信道划分MAC（静态分配信道）" class="headerlink" title="信道划分MAC（静态分配信道）"></a>信道划分MAC（静态分配信道）</h4><h5 id="频分、时分"><a href="#频分、时分" class="headerlink" title="频分、时分"></a>频分、时分</h5><p>频分复用(FDM, Frequency Division Multiplexing)、时分复用(TDM)、统计时分复用(STDM)</p>
<ul>
<li>FDM:<ul>
<li>用户通信始终占用分配到的频带</li>
</ul>
</li>
<li>TDM：有利于数字信号的传输<ul>
<li>不同时间占用不同的频带宽度 </li>
</ul>
</li>
<li>STDM：又称为异步时分复用<ul>
<li><img src="/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/2%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210824222555789.png" alt="image-20210824222555789" style="zoom:50%;"></li>
</ul>
</li>
</ul>
<h5 id="波分、码分"><a href="#波分、码分" class="headerlink" title="波分、码分"></a>波分、码分</h5><p>波分复用(Wavelength)、码分复用(Code)</p>
<ul>
<li>WDM：就是光的频分复用，一根光纤传输多个频率很接近的光载波信号<ul>
<li>Desne WDM,DWDM，密集波分复用</li>
</ul>
</li>
<li>CDM：也叫CDMA，码分多址<ul>
<li>比特时间被分成m个更短的时间槽称为<strong>码片</strong>，通常每个比特64或者128个码片，每个站点被指定一个唯一的m位码片序列</li>
<li>数据发送：当两个或多个站点同时发送的时候，数据在信道中<strong>线性相加</strong>（保证信道利用率），为了能分离信号，要求码片序列之间<strong>相互正交</strong>（保证数据不相互干扰）。</li>
<li>数据分离：合并的数据和源站规格化内积再除以向量的分量个数。</li>
</ul>
</li>
</ul>
<h4 id="随机MAC（动态分配信道）"><a href="#随机MAC（动态分配信道）" class="headerlink" title="随机MAC（动态分配信道）"></a>随机MAC（动态分配信道）</h4><h5 id="ALOHA协议"><a href="#ALOHA协议" class="headerlink" title="ALOHA协议"></a>ALOHA协议</h5><h6 id="纯ALOHA协议"><a href="#纯ALOHA协议" class="headerlink" title="纯ALOHA协议"></a>纯ALOHA协议</h6><ol>
<li>思想：不监听信道；不按时间槽发送，<strong>想发就发</strong>；随机重发。</li>
</ol>
<img src="/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/2%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210824231312644.png" alt="image-20210824231312644" style="zoom: 50%;">

<h6 id="时隙ALOHA协议"><a href="#时隙ALOHA协议" class="headerlink" title="时隙ALOHA协议"></a>时隙ALOHA协议</h6><ol>
<li>思想：同步各个站点的时间，将时间划分成等长的时隙（slot），规定只能<strong>在每个时隙开始的时候才能发送一个帧</strong>。</li>
<li>效率比纯ALOHA协议高了一倍。</li>
</ol>
<h5 id="CSMA协议"><a href="#CSMA协议" class="headerlink" title="CSMA协议"></a>CSMA协议</h5><p>载波侦听多路访问（CSMA）</p>
<ol>
<li>$1$-坚持CSMA<ul>
<li>侦听到信道忙后，继续侦听信道；一直侦听到信道空闲之后，发送帧的概率为1，就立即发送数据。</li>
<li>缺点：传播延迟对协议的性能影响比较大（例如两个节点都想发送数据）</li>
</ul>
</li>
<li>非坚持CSMA<ul>
<li>侦听到信道空闲之后，就立即发送数据；侦听到信道忙之后，放弃侦听，就等待一个随机的时间后再重复侦听。</li>
<li>缺点：增加了延迟。优点：提高了信道利用率。</li>
</ul>
</li>
<li>$p-$坚持CSMA：用于时分信道<ul>
<li>侦听信道，如果忙的话，就持续侦听，直至信道空闲；如果侦听到空闲，就以概率$p$发送数据，以概率$1-p$推迟到下一个时隙，重复此过程。</li>
<li>优点：是上面两个的折衷方案。</li>
</ul>
</li>
</ol>
<img src="/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/2%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210824234459835.png" alt="image-20210824234459835" style="zoom:67%;">

<h5 id="CSMA-CD协议-rightarrow-适用于总线型网络或者半双工网络环境。"><a href="#CSMA-CD协议-rightarrow-适用于总线型网络或者半双工网络环境。" class="headerlink" title="CSMA/CD协议$\rightarrow$适用于总线型网络或者半双工网络环境。"></a>CSMA/CD协议$\rightarrow$适用于总线型网络或者半双工网络环境。</h5><p>载波侦听多路访问/碰撞检测。****</p>
<ul>
<li>工作流程：<strong>先听后发，边听边发，冲突停发，随机重发</strong><ul>
<li>适配器听到信道空闲，则开始传输帧；如果适配器听到信道忙，一直侦听到不忙，然后传输。</li>
<li>传输的过程中，适配器检测来自其它适配器的能量，如果期间没有检测到来自其他适配器的信号能量，那么就完成了传输；否则，适配器停止传输它的帧，取而代之的是一个48比特的拥塞信号。</li>
<li>在中止（即传输拥塞信号）后，适配器采用截断二进制指数退避算法等待一段随机时间后继续侦听信道。</li>
</ul>
</li>
<li>总线的传播时延对此协议影响很大。</li>
<li>为了保证发送的时候能检测到可能存在的冲突，帧的传输时延至少要两倍于信号在总线中的传播时延，因此帧的长度要大于一个最小帧长（=总线传播时延*数据传输率*2）。</li>
<li>二进制指数退避算法<ul>
<li>$重传次数k=min{重传次数，10}，离散整数集合{0，1，3,7,15,2^k-1}随机取数为r，争用周期为\tau$</li>
<li>退避时间为：$2r\tau$</li>
</ul>
</li>
</ul>
<h5 id="CSMA-CA协议-rightarrow-适用于无线连接的局域网"><a href="#CSMA-CA协议-rightarrow-适用于无线连接的局域网" class="headerlink" title="CSMA/CA协议$\rightarrow$适用于无线连接的局域网"></a>CSMA/CA协议$\rightarrow$适用于无线连接的局域网</h5><p>载波侦听多路访问/碰撞避免</p>
<ul>
<li><p>碰撞避免的方式：</p>
<ul>
<li>预约信道：通知其它站点自己所需时间</li>
<li>ACK帧：所有站点接收到发给自己的数据帧（除了广播帧、组播帧之后，都需要发送一个ACK帧）</li>
<li>TSC/CTS帧，用于解决隐蔽站的问题。</li>
</ul>
</li>
<li><p>​    与CD的区别</p>
<ul>
<li>可以避免，但是不能完全避免。</li>
<li>传输介质不同：CD是用于总线型以太网；CA用于无线局域网（802.11a/b/g/n）</li>
<li>检测方式不同，CD是检测电压电话，CA采用能量检测、载波检测（与伪随机码运算比较）、能量载波混合检测。</li>
<li>在本节点没有冲突，不表示在接收节点出没有冲突。</li>
</ul>
</li>
</ul>
<h4 id="轮询访问MAC：令牌传递协议（动态分配信道）"><a href="#轮询访问MAC：令牌传递协议（动态分配信道）" class="headerlink" title="轮询访问MAC：令牌传递协议（动态分配信道）"></a>轮询访问MAC：令牌传递协议（动态分配信道）</h4><p>一个监控站以循环方式轮询每个节点，决定信道的分配。</p>
<p>令牌在各个节点间以某个固定次序交换。</p>
<h3 id="局域网"><a href="#局域网" class="headerlink" title="局域网"></a>局域网</h3><p>介质访问控制协议包括CSMA/CD、令牌总线和令牌环，适用上前两个是总线型局域网，最后一个是环形局域网</p>
<p>局域网的数据链路层</p>
<ol>
<li>LAN优点：<ol>
<li>具有广播功能</li>
<li>便于系统的扩展和演变</li>
<li>提高了系统的可靠性、可用性、生存性</li>
</ol>
</li>
<li>分类<ol>
<li>星形网</li>
<li>环形网</li>
<li>总线网</li>
</ol>
</li>
<li>共享信道<ol>
<li>静态划分信道：FDM,TDM,WDM,CDM</li>
<li>动态媒体接入控制（多点接入）:信道并非在用户通信时固定给用户<ol>
<li>随机接入</li>
<li>受控接入</li>
</ol>
</li>
</ol>
</li>
</ol>
<img src="/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/2%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210824154702057.png" alt="image-20210824154702057" style="zoom:80%;">

<ul>
<li>通常将802.3局域网简称为以太网。<ul>
<li>采用无连接的工作方式</li>
<li>不对数据帧编号，不要求确认。尽最大努力交付数据，不可靠服务。差错纠正由高层完成。</li>
</ul>
</li>
<li>注意：全双工方式不需要争用信道，也就不需要CSMA/CD协议。高速以太网既能半双工，也能全双工。</li>
<li>IEEE 802.11<ul>
<li>采用CSMA/CA</li>
</ul>
</li>
</ul>
<h3 id="广域网"><a href="#广域网" class="headerlink" title="广域网"></a>广域网</h3><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><ul>
<li>由交换机组成（交换机只能在单个网络中转发分组，路由器可以在多个网络之间转发分组）</li>
<li>广域网协议主要在网络层</li>
</ul>
<h4 id="PPP协议"><a href="#PPP协议" class="headerlink" title="PPP协议"></a>PPP协议</h4><p><strong>PPP协议</strong></p>
<ol>
<li>定义：PPP协议是用户计算机和ISP进行通信的时候所使用的数据链路层协议</li>
<li>要求：简单（提供不可靠的数据报服务即可）、封装成帧、透明性（数据中帧定界符的解决）、支持多种网络层协议、多种类型链路（串行并行、同步异步、低速高速、光电、交换非交换）、差错检测（及时丢弃有差错的帧）、检测连接状态、最大传送单元、网络地址协商（知道对方的地址）、数据压缩协商。</li>
<li>协议组成：<ol>
<li>将IP数据报封装到串行链路</li>
<li>一个用来建立、配置和测试数据链路连接的链路控制协议（LCP）</li>
<li>一套网络控制协议（NCP），以支持不同的网络层协议</li>
</ol>
</li>
<li>帧格式<ul>
<li><img src="/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/2%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210824145840156.png" alt="image-20210824145840156"></li>
<li>字节填充（把0x7E转义），用于异步传输<ol>
<li>信息字段中的0x7E编转成2字节的（0x7D, 0x5E）</li>
<li>0x7D转成（0x7D, 0x5D）</li>
<li>信息字段中出现ASCII码的控制字符（小于0x20的），前面加一个0x7D</li>
</ol>
</li>
<li>零比特填充。用于同步传输<ul>
<li>5个连续的1就填充一个0</li>
</ul>
</li>
</ul>
</li>
<li>链路控制协议（LCP）网络控制协议（NCP）<ul>
<li><img src="/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/2%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210824153133032.png" alt="image-20210824153133032" style="zoom:80%;"></li>
</ul>
</li>
</ol>
<h4 id="HDLC协议"><a href="#HDLC协议" class="headerlink" title="HDLC协议"></a>HDLC协议</h4><ul>
<li>高级数据链路控制协议<ul>
<li>面向比特的数据链路层协议。PPP是面向字节的</li>
</ul>
</li>
</ul>
<img src="/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/2%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210825004001056.png" alt="image-20210825004001056" style="zoom:80%;">



<h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><h3 id="网络层的功能"><a href="#网络层的功能" class="headerlink" title="网络层的功能"></a>网络层的功能</h3><ol>
<li><strong>路由选择</strong>：根据网络拓扑情况，动态地改变所选择的路由。</li>
<li><strong>分组转发</strong>：根据转发表将用户的IP数据报从合适的端口转发出去。<ol>
<li>路由表：根据路由选择算法得出：转发表：由路由表得出的</li>
</ol>
</li>
<li>拥塞控制：<ol>
<li>判断：网络负载增加，发现吞吐量小了，证明由拥塞。</li>
<li>作用：确保子网能够承载所达到的流量。设置主机、路由器及路由器内部的转发处理过程，单一地增加资源并不能解决拥塞。</li>
<li>方法：<ol>
<li><strong>开环控制（静态）：</strong>设计网络时避免会发生拥塞的因素。<ul>
<li>包括：何时可以接收新流量、何时可丢弃分组及丢弃哪些分组、确定何种调度决策</li>
</ul>
</li>
<li><strong>闭环控制（动态）：</strong>检测网络实时发生的拥塞，将拥塞信息传到合适的地方，调整网络系统的运行</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="路由算法"><a href="#路由算法" class="headerlink" title="路由算法"></a>路由算法</h3><ol>
<li>路由算法分类：<ol>
<li>静态路由算法（非自适应路由算法）<ul>
<li>手工配置的路由信息</li>
</ul>
</li>
<li>动态路由算法（自适应路由算法）<ul>
<li>路由器间彼此交换信息，按照一定的算法优化得到的</li>
</ul>
</li>
</ol>
</li>
<li><strong>距离-向量路由算法</strong><ol>
<li>原理：结点将其路由选择表（<strong>每条路经的目的地</strong>；<strong>路经的代价</strong>）定期传送给<strong>相邻节点</strong>。</li>
<li>路由表更新原则：（1）有新的路由；（2）有路径代价低的路由</li>
<li>代表算法：路由信息协议：<strong>RIP算法</strong>：使用“跳数”作为距离的度量、</li>
<li>评价：可能会遇到路由环路等情况</li>
</ol>
</li>
<li><strong>链路状态路由算法</strong><ol>
<li>原理：要求每个结点都具有完全相同的网络拓扑信息。（1）主动测试邻接结点的状态；（2）定期将链路状态传播给<strong>所有其他结点</strong>（或称路由节点）</li>
<li>代表算法：<strong>OSPF算法</strong>（<u>网络层协议，使用IP数据报传送；RIP是应用层协议，在传输层使用UDP</u>）</li>
<li>链路状态路由算法特征：<ol>
<li>向本自治系统所有路由器发送信息，使用洪泛法。</li>
<li>发送的信息是与路由器相邻的所有路由器的链路状态（相邻信息及该链路的费用、距离、时延、带宽）。</li>
<li>只有链路状态变化时，才发送消息</li>
</ol>
</li>
<li>迪杰斯特拉算法计算单源最短路径</li>
</ol>
</li>
<li>层次路由<ol>
<li>因特网将整个互联网划分成许多小的自治系统</li>
<li>分类：<ol>
<li>内部网关协议（IGP）/域内路由选择<ul>
<li>包括：RIP和OSPF</li>
</ul>
</li>
<li>外部网关协议（EGP）/域间路由选择<ul>
<li><strong>BGP</strong>（<u>应用层协议，基于TCP</u>）</li>
<li><img src="/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/2%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210830093424482.png" alt="image-20210830093424482"></li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="IPv4"><a href="#IPv4" class="headerlink" title="IPv4"></a>IPv4</h3><ol>
<li>IPV4分组<ol>
<li>格式：首部+尾部</li>
<li>IP数据报分片：<ul>
<li>当IP数据报的总长度大于链路的MTU时，需要将IP数据报中的数据分装在两个或多个较小的IP数据报中，称为片</li>
<li>数据报中由标志位（MF位（1表示<u>还有更多分片</u>），DF位（1表示<u>不要分片</u>））标识分片。</li>
</ul>
</li>
<li>转发分组流程<ol>
<li>路由器提取IP数据报首部获得主机的IP地址D，得出目的网络地址N；</li>
<li>若N与此路由器直接相连，则直接交付；否则，执行3</li>
<li>若路由表中有目的地址为D的特定主机路由，则将数据报传送给下一跳路由（通过ARP转成MAC地址，使用MAC帧传输，下同）；否则执行4</li>
<li>若路由表中有到达网络N的路由，则把数据报传送给路由表指明的下一跳路由；否则执行5</li>
<li>若路由表中有一个默认路由，则把数据报传送给路由表指明的下一跳路由；否则执行6</li>
<li>报告转发分组出错。</li>
</ol>
</li>
</ol>
</li>
<li>IPV4地址与NAT<ul>
<li><img src="/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/2%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210829235726192.png" alt="image-20210829235726192" style="zoom:80%;"></li>
<li><img src="/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/2%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210830001031567.png" alt="image-20210830001031567" style="zoom:80%;"></li>
<li>IP地址的特点：<ol>
<li>由网络号和主机号构成</li>
<li>IP地址是标识主机/路由器和一条链路的接口。因此一个主机连接多个网络就有多个IP。（路由器至少有2个IP地址）</li>
<li>用转发器或者桥接器连接的若干LAN仍然是一个网络</li>
<li>在IP地址中，所有分配到的网络都是平等的</li>
</ol>
</li>
<li>NAT(网络地址转换)<ul>
<li>将专用网络地址转换为公用地址</li>
<li>私有IP：<ul>
<li><img src="/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/2%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210830001611121.png" alt="image-20210830001611121"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>子网划分与子网掩码、CIDR<ol>
<li>子网划分<ol>
<li>IP：｛&lt;网络号&gt;，&lt;子网号&gt;，&lt;主机号&gt;｝</li>
<li>子网号占用了主机号地址</li>
</ol>
</li>
<li>子网掩码<ol>
<li>由一串1和跟随的一串0构成，1对应IP地址中的网络号和子网号，0对应主机号。</li>
<li>IP地址与子网掩码进行“与”运算，就可得到子网的网络地址。</li>
<li><img src="/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/2%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210830002223106.png" alt="image-20210830002223106"></li>
</ol>
</li>
<li>无分类域间路由选择（CIDR）</li>
</ol>
</li>
<li>ARP、DHCP与ICMP<ol>
<li>IP地址与硬件地址：<ol>
<li>网络层采用IP地址</li>
<li>到达目的网络之后采用MAC地址寻找目的</li>
</ol>
</li>
<li>地址解析协议ARP<ol>
<li>每个主机维持一个ARP表，存放主机和路由器IP到MAC地址的映射表。</li>
<li>工作原理：<ol>
<li>A向B发送IP数据报；</li>
<li>现在ARP高速缓存中查看有无B的IP，有则查出其硬件地址并写入MAC帧，接着进行发送；</li>
<li>若没有，广播ARP分组，B收到ARP分组之后，发出响应ARP分组，这样A就收到了B的IP与MAC地址的映射。</li>
</ol>
</li>
<li><strong>ARP工作在网络层；NAT工作在传输层。</strong></li>
</ol>
</li>
<li>动态主机配置协议DHCP<ol>
<li>基于UDP的，因为TCP需要建立连接</li>
</ol>
</li>
<li>网际控制报文协议ICMP：IP层协议<ol>
<li>目的：让主机或路由器报告差错和异常。</li>
<li>分类<ol>
<li>ICMP<strong>差错</strong>报文<ul>
<li>终点不可达；源点抑制（因为拥塞导致数据交付失败）；时间超过（终点发送的）；参数问题；改变路由。</li>
</ul>
</li>
<li>ICMP<strong>询问</strong>报文<ul>
<li>回送请求和回答报文、时间戳请求和回答报文、掩码地址请求和回答报文、路由询问和通告报文。</li>
</ul>
</li>
<li>应用<ol>
<li>PING：回送请求和回答报文<ul>
<li>PING工作在==应用层==</li>
</ul>
</li>
<li>Traceroute/tracert：ICMP时间超过报文<ul>
<li>工作在==网络层==</li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h3><ul>
<li>解决IP地址耗尽的方式：<ul>
<li>无类别编址CIDR    </li>
<li>NAT网络地址转换</li>
<li>IPv6</li>
</ul>
</li>
</ul>
<ol>
<li>IPV6主要特点：地址空间大（128位）；即插即用；资源预分配；安全性；端到端的，数据不能分片。</li>
<li>IPV6地址</li>
</ol>
<h3 id="路由协议"><a href="#路由协议" class="headerlink" title="路由协议"></a>路由协议</h3><h4 id="自治系统（Autonormous-System）"><a href="#自治系统（Autonormous-System）" class="headerlink" title="自治系统（Autonormous System）"></a>自治系统（Autonormous System）</h4><p>单一技术下管理的一组路由器</p>
<h4 id="域内路由与域间路由"><a href="#域内路由与域间路由" class="headerlink" title="域内路由与域间路由"></a>域内路由与域间路由</h4><ol>
<li>域内路由选择（内部网关协议，IGP）：AS内的路由选择</li>
<li>域间路由选择（外部网关协议，EGP）：AS间的</li>
</ol>
<h4 id="路由信息协议（RIP）"><a href="#路由信息协议（RIP）" class="headerlink" title="路由信息协议（RIP）"></a>路由信息协议（RIP）</h4><p>属于应用层协议，使用UDP传播；</p>
<p>优点：实现简单、开销小、收敛过程较快</p>
<p>缺点：网络规模受限；网络规模大则开销大；网络出现故障，则需要较长信息才能传播至所有路由。</p>
<h4 id="开放最短路径优先（OSPF）"><a href="#开放最短路径优先（OSPF）" class="headerlink" title="开放最短路径优先（OSPF）"></a>开放最短路径优先（OSPF）</h4><h4 id="协议边界网关协议（BGP）"><a href="#协议边界网关协议（BGP）" class="headerlink" title="协议边界网关协议（BGP）"></a>协议边界网关协议（BGP）</h4><h3 id="IP组播（应用于UDP）"><a href="#IP组播（应用于UDP）" class="headerlink" title="IP组播（应用于UDP）"></a>IP组播（应用于UDP）</h3><h4 id="组播概念"><a href="#组播概念" class="headerlink" title="组播概念"></a>组播概念</h4><p>一对多发送</p>
<img src="/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/2%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210830093627990.png" alt="image-20210830093627990" style="zoom: 67%;">

<h4 id="IP组播地址"><a href="#IP组播地址" class="headerlink" title="IP组播地址"></a>IP组播地址</h4><p>采用D类地址：224.0.0.0~239.255.255.255</p>
<ul>
<li>特点：<ul>
<li>尽最大努力交付</li>
<li>只能用于目的地址，不能用于源地址</li>
<li>对组播数据报不产生ICMP差错报文，因此ping命令行不通</li>
<li>并非所有硬件地址都可以组播</li>
</ul>
</li>
</ul>
<h4 id="IGMP与组播路由算法"><a href="#IGMP与组播路由算法" class="headerlink" title="IGMP与组播路由算法"></a>IGMP与组播路由算法</h4><p>因特网组管理协议（IGMP）</p>
<img src="/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/2%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210830094609674.png" alt="image-20210830094609674" style="zoom:80%;">

<h3 id="移动IP"><a href="#移动IP" class="headerlink" title="移动IP"></a>移动IP</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><h4 id="通信过程"><a href="#通信过程" class="headerlink" title="通信过程"></a>通信过程</h4><h3 id="网络层设备"><a href="#网络层设备" class="headerlink" title="网络层设备"></a>网络层设备</h3><h4 id="路由器的组成与功能"><a href="#路由器的组成与功能" class="headerlink" title="路由器的组成与功能"></a>路由器的组成与功能</h4><h4 id="路由表与路由转发"><a href="#路由表与路由转发" class="headerlink" title="路由表与路由转发"></a>路由表与路由转发</h4><p><img src="/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/2%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210830095054038.png" alt="image-20210830095054038"></p>
<h2 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h2><h3 id="传输层提供的服务"><a href="#传输层提供的服务" class="headerlink" title="传输层提供的服务"></a>传输层提供的服务</h3><ol>
<li>传输层功能：<ol>
<li>进程间逻辑通信；网络层是主机之间的逻辑通信。</li>
<li>复用和分用：<ol>
<li>复用：不同进程使用同一个传输层协议</li>
<li>分用：接收方在收到数据后可以正确交付到目的应用进程</li>
<li>网络层的复用分用：<ol>
<li>复用：不同协议的数据都可以封装成IP数据报发送出去</li>
<li>分用：接收方的网络层在剥去首部之后将数据交付给相应的协议</li>
</ol>
</li>
</ol>
</li>
<li>差错检测（首部和数据部分）</li>
<li>提供面向连接的TCP和无连接的UDP</li>
</ol>
</li>
<li>传输层的寻址与端口<ol>
<li>端口是传输层的服务访问点（SAP）；IP地址是网络层的SAP；MAC地址是数据链路层的。</li>
<li>通过IP地址区分主机，通过端口号标识和区分主机中的不同应用进程。</li>
<li>套接字=（主机IP地址，端口号）</li>
</ol>
</li>
</ol>
<h3 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h3><h4 id="UDP数据报"><a href="#UDP数据报" class="headerlink" title="UDP数据报"></a>UDP数据报</h4><ol>
<li>优点：<ol>
<li>无须建立连接</li>
<li>开销小：维持开销和分组首部的开销</li>
<li>发送速度快</li>
</ol>
</li>
<li>报文是UDP数据报处理的最小单位</li>
<li>使用UDP的网络应用，其数据传输的可靠性由应用层负责。</li>
<li>UDP数据报的长度不包括伪首部的长度</li>
</ol>
<h4 id="UDP检验"><a href="#UDP检验" class="headerlink" title="UDP检验"></a>UDP检验</h4><p><img src="/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/2%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210830101850817.png" alt="image-20210830101850817"></p>
<h3 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h3><h4 id="TCP协议的特点"><a href="#TCP协议的特点" class="headerlink" title="TCP协议的特点"></a>TCP协议的特点</h4><ol>
<li>面向连接</li>
<li>点对点的</li>
<li>可靠交付：数据无差错、不丢失、不重复且有序</li>
<li>全双工通信</li>
<li>面向字节流的</li>
</ol>
<h4 id="TCP报文段"><a href="#TCP报文段" class="headerlink" title="TCP报文段"></a>TCP报文段</h4><img src="/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/2%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210830102102384.png" alt="image-20210830102102384" style="zoom:80%;">

<h4 id="TCP连接管理"><a href="#TCP连接管理" class="headerlink" title="TCP连接管理"></a>TCP连接管理</h4><ol>
<li>连接建立：三次握手<ul>
<li><img src="/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/2%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210830102326027.png" alt="image-20210830102326027" style="zoom:80%;"></li>
<li>第二次握手服务端分配好资源（分配TCP缓存和变量）；第三次握手分配客户端资源。</li>
<li>前两次握手不携带应用数据，但是需要消耗序号；第三次携带数据则消耗序号，不携带则不消耗。</li>
</ul>
</li>
<li>数据传送</li>
<li>连接释放：四次握手<ul>
<li><img src="/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/2%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210830102802926.png" alt="image-20210830102802926" style="zoom:80%;"></li>
<li><img src="/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/2%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210830103020413.png" alt="image-20210830103020413"></li>
</ul>
</li>
</ol>
<h4 id="TCP可靠传输"><a href="#TCP可靠传输" class="headerlink" title="TCP可靠传输"></a>TCP可靠传输</h4><ol>
<li>序号<ul>
<li>保证数据能有序提交给应用层</li>
<li>序号是报文段发送的数据的第一个字节的序号</li>
</ul>
</li>
<li>确认<ul>
<li>确认号：希望收到的下一个报文段的序号</li>
<li>累计确认：只确认到第一个丢失字节为止的字节</li>
</ul>
</li>
<li>重传<ol>
<li>超时<ul>
<li><strong>超时重传时间</strong>稍大于<strong>加权平均往返时间</strong></li>
</ul>
</li>
<li>冗余ACK<ul>
<li>A给B发送数据12345，B只收到了1345，因此在收到就发送三个对1的确认，希望收到2号报文段</li>
</ul>
</li>
</ol>
</li>
</ol>
<h4 id="TCP流量控制"><a href="#TCP流量控制" class="headerlink" title="TCP流量控制"></a>TCP流量控制</h4><p>基于滑动窗口协议的流量控制机制</p>
<h4 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h4><ol>
<li>与流量控制对比<ol>
<li>同：都是控制发送方的发送速率</li>
<li>区别：<ol>
<li>拥塞控制是让网络承受现有的网络负荷，是一个全局性的过程</li>
<li>流量控制是点对点的</li>
</ol>
</li>
</ol>
</li>
<li>发送方维持两个窗口：<ol>
<li>接收窗口rwnd<ul>
<li>接收方根据目前接收缓存的大小许诺的最新窗口值，反映接收方的容量。由接收方通知发送方的</li>
</ul>
</li>
<li>拥塞窗口cwnd<ul>
<li>发送方根据自己估算的网络拥塞程度设置的窗口值，反映网络当前容量</li>
</ul>
</li>
</ol>
</li>
<li>发送窗口上限值=$min[rwnd,cwnd]$</li>
<li>拥塞控制算法：<ol>
<li>慢开始：拥塞窗口（$cwnd$）慢慢变大，扩大到慢开始门限，就改用拥塞避免算法</li>
<li>拥塞避免：发送端的拥塞窗口$cwnd$每经过一个往返时延RRT就增加一个MSS（$cwnd+1$）的大小（加法增大）；当出现一次超时，令慢开始门限等于当前$cwnd$的一半（乘法减小）<img src="/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/2%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210830113844616.png" alt="image-20210830113844616" style="zoom:80%;"></li>
<li>快重传：收到3个重复的ACK报文的时候，就重传。</li>
<li>快恢复：收到3个重复的ACK的时候，执行”乘法减小“，将$cwnd$设置成慢开始门限改变后的数值，然后执行拥塞避免算法。<img src="/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/2%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210830114321303.png" alt="image-20210830114321303" style="zoom:80%;"></li>
<li>实际应用中，检测到超时，就采用慢开始和拥塞避免；接受到冗余ACK，就采用快重传和快恢复。</li>
</ol>
</li>
</ol>
<p><img src="/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/2%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210830114517007.png" alt="image-20210830114517007"></p>
<h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><h3 id="网络应用模型"><a href="#网络应用模型" class="headerlink" title="网络应用模型"></a>网络应用模型</h3><ol>
<li>客户端/服务器模型<ol>
<li>特点：<ol>
<li>客户是服务请求方，服务器是服务提供方</li>
<li>服务端可以管理客户机</li>
<li>客户机相互之间不直接通信</li>
<li>可扩展性不佳</li>
</ol>
</li>
<li>代表：Web, FTP, 远程登录，电子邮件</li>
</ol>
</li>
<li>P2P模型<ol>
<li>优点：<ol>
<li>减轻了服务器的计算压力</li>
<li>多个客户端共享文档</li>
<li>可扩展性好</li>
<li>网络健壮性强</li>
</ol>
</li>
<li>缺点：提供服务会占用内存；加大了网络的拥塞</li>
<li>代表：PPlive, Bittorrent, 电驴</li>
</ol>
</li>
</ol>
<h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h3><ol>
<li>层次域名空间<img src="/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/2%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210830134000472.png" alt="image-20210830134000472" style="zoom: 50%;"><ol>
<li>国家顶级域名：cn,us</li>
<li>通用顶级域名：.com, .org, .gov</li>
<li>基础结构域名：arpa，反向域名解析</li>
</ol>
</li>
<li>域名服务器<ol>
<li>根域名服务器</li>
<li>顶级域名服务器</li>
<li>授权域名服务器</li>
<li>本地域名服务器（配置网络填写的DNS地址）</li>
</ol>
</li>
<li>解析器，使用UDP<ol>
<li>域名映射成IP，正向解析；IP映射成域名，反向解析。</li>
<li></li>
</ol>
</li>
</ol>
<h3 id="FTP"><a href="#FTP" class="headerlink" title="FTP"></a>FTP</h3><ul>
<li>FTP客户端和服务器传递FTP命令的时候，使用的连接是”建立在UDP之上的控制连接“</li>
</ul>
<h3 id="电子邮件"><a href="#电子邮件" class="headerlink" title="电子邮件"></a>电子邮件</h3><h3 id="WWW"><a href="#WWW" class="headerlink" title="WWW"></a>WWW</h3><p><img src="/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/2%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210830134817220.png" alt="image-20210830134817220"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://naixil.github.io/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/3Java%E7%9F%A5%E8%AF%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Li Xian">
      <meta itemprop="description" content="与遗忘作斗争">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LiXian's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/3Java%E7%9F%A5%E8%AF%86/" class="post-title-link" itemprop="url">Java笔试常见问题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-09-01 00:00:01" itemprop="dateCreated datePublished" datetime="2021-09-01T00:00:01+08:00">2021-09-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-09-20 18:12:11" itemprop="dateModified" datetime="2021-09-20T18:12:11+08:00">2021-09-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/" itemprop="url" rel="index"><span itemprop="name">计算机基础知识总结</span></a>
                </span>
            </span>

          
            <span id="/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/3Java%E7%9F%A5%E8%AF%86/" class="post-meta-item leancloud_visitors" data-flag-title="Java笔试常见问题" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/3Java%E7%9F%A5%E8%AF%86/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/3Java%E7%9F%A5%E8%AF%86/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>23k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>21 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="一、小知识点"><a href="#一、小知识点" class="headerlink" title="一、小知识点"></a>一、小知识点</h1><h2 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">int</span>)(Math.pow(matrix.length, <span class="number">2</span>))</span><br></pre></td></tr></table></figure>

<h2 id="生成随机数"><a href="#生成随机数" class="headerlink" title="生成随机数"></a>生成随机数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生成0~1之间的随机数（浮点数）</span></span><br><span class="line">Math.random();</span><br><span class="line">(<span class="keyword">int</span>)(<span class="number">1</span> + Math.random()*<span class="number">10</span>); <span class="comment">// 1~10之间的整数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Random();</span><br><span class="line">Random random =<span class="keyword">new</span> Random();</span><br><span class="line"><span class="keyword">int</span> r1 = random.nextInt(<span class="number">100</span>); <span class="comment">// 生成一个0~100的随机数（整型）</span></span><br></pre></td></tr></table></figure>

<h2 id="集合常用方法"><a href="#集合常用方法" class="headerlink" title="集合常用方法"></a>集合常用方法</h2><h3 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h3><p><img src="/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/3Java%E7%9F%A5%E8%AF%86/image-20210915002131383.png" alt="image-20210915002131383"></p>
<h3 id="List特有"><a href="#List特有" class="headerlink" title="List特有"></a>List特有</h3><p><img src="/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/3Java%E7%9F%A5%E8%AF%86/image-20210915002155864.png" alt="image-20210915002155864"></p>
<h3 id="LinkedList特有"><a href="#LinkedList特有" class="headerlink" title="LinkedList特有"></a>LinkedList特有</h3><p><img src="/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/3Java%E7%9F%A5%E8%AF%86/image-20210915002218084.png" alt="image-20210915002218084"></p>
<h3 id="Map特有"><a href="#Map特有" class="headerlink" title="Map特有"></a>Map特有</h3><p><img src="/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/3Java%E7%9F%A5%E8%AF%86/image-20210915002245560.png" alt="image-20210915002245560"></p>
<h3 id="Stack特有"><a href="#Stack特有" class="headerlink" title="Stack特有"></a>Stack特有</h3><p><img src="/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/3Java%E7%9F%A5%E8%AF%86/image-20210915002302462.png" alt="image-20210915002302462"></p>
<h3 id="Queue特有"><a href="#Queue特有" class="headerlink" title="Queue特有"></a>Queue特有</h3><p><img src="/2021/09/01/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/3Java%E7%9F%A5%E8%AF%86/image-20210915002325953.png" alt="image-20210915002325953"></p>
<h2 id="牛客编程特点System-in"><a href="#牛客编程特点System-in" class="headerlink" title="牛客编程特点System.in"></a>牛客编程特点System.in</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算a+b的值</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">while</span>(in.hasNextInt())&#123;</span><br><span class="line">            <span class="keyword">int</span> a = in.nextInt();</span><br><span class="line">            <span class="keyword">int</span> b = in.nextInt();</span><br><span class="line">            System.out.println(a + b);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="字符串转整型"><a href="#字符串转整型" class="headerlink" title="字符串转整型"></a>字符串转整型</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">java中的语句integer.parseint（)是将整型数据Integer转换为基本数据类型int</span><br><span class="line">例子：</span><br><span class="line">String str = ＂3＂;</span><br><span class="line">int i = Integer.parseInt(str);</span><br><span class="line">System.out.println(i+1)；//输出4;</span><br><span class="line">String str = ＂3＂;</span><br><span class="line">System.out.println(str+1);//output 31;</span><br><span class="line">integer，整数 / 整型数，与小数 / 浮点数相对，是编程语言的基本数据类型之一，用以指示变量的数据类型，有时也用于常量（变量、表达式）的强制数据类型转换。整型数据的长度及其取值范围并不固定，受编译环境影响。</span><br></pre></td></tr></table></figure>

<h2 id="字符串转字符数组（“123a”-rightarrow-1-2-3-a-）"><a href="#字符串转字符数组（“123a”-rightarrow-1-2-3-a-）" class="headerlink" title="字符串转字符数组（“123a”$\rightarrow$[1,2,3,a]）"></a>字符串转字符数组（“123a”$\rightarrow$[1,2,3,a]）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String strs = <span class="string">&quot;123&quot;</span>;</span><br><span class="line"><span class="comment">// int arrs = Integer.parseInt(strs);</span></span><br><span class="line"><span class="keyword">char</span>[] arrs = strs.toCharArray();</span><br><span class="line">System.out.println(Arrays.toString(arrs));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">char</span> arr: arrs)&#123;</span><br><span class="line">System.out.println(arr);</span><br></pre></td></tr></table></figure>



<h1 id="二、Java刷题笔记——简单题（for-编程题）"><a href="#二、Java刷题笔记——简单题（for-编程题）" class="headerlink" title="二、Java刷题笔记——简单题（for 编程题）"></a>二、Java刷题笔记——简单题（for 编程题）</h1><h2 id="纯纯的算法"><a href="#纯纯的算法" class="headerlink" title="纯纯的算法"></a>纯纯的算法</h2><h3 id="JZ-10-I-斐波那契数列求第N个数"><a href="#JZ-10-I-斐波那契数列求第N个数" class="headerlink" title="JZ_10-I:斐波那契数列求第N个数"></a>JZ_10-I:斐波那契数列求第N个数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// System.out.println(&quot;Hello, World!&quot;);</span></span><br><span class="line">        fibs fibs = <span class="keyword">new</span> fibs();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> num = fibs.fib(<span class="number">100000001</span>);</span><br><span class="line">        System.out.println(num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">fibs</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> MOD = <span class="number">100000008</span>;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// r用来存最新的数；（n_i, n_i+1, n_i+2），因为计算的过程中n_i是没用的，</span></span><br><span class="line">        <span class="comment">// 所以把n_i用来当中转</span></span><br><span class="line">        <span class="keyword">int</span> p = <span class="number">0</span>, q = <span class="number">0</span>, r = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            q = p;</span><br><span class="line">            p = r;</span><br><span class="line">            r = (p + q) % MOD;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="JZ-10-II-青蛙跳台阶"><a href="#JZ-10-II-青蛙跳台阶" class="headerlink" title="JZ_10_II:青蛙跳台阶"></a>JZ_10_II:青蛙跳台阶</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JZ_10_II_Frog</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    青蛙可以跳一个或者2个台阶，跳上n个台阶共有多少种跳法</span></span><br><span class="line"><span class="comment">     * 思路： 开始时： 跳上一级台阶，此时还剩下f(n-1)种跳法 跳上两级台阶，此时还剩下f(n-2)种跳法 则f(n)=f(n_1) + f(n-2),</span></span><br><span class="line"><span class="comment">     * f(0) = 1, f(1) = 1, f(2) = 2</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> Solution();</span><br><span class="line">        <span class="keyword">int</span> num = solution.numWays(<span class="number">7</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;青蛙跳台阶的个数是：&quot;</span> + num);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numWays</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> MOD = <span class="number">1000000007</span>;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">1</span>, sum;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            sum = (a + b) % MOD;</span><br><span class="line">            a = b;</span><br><span class="line">            b = sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="JZ-15-求整数对应的二进制数1的个数"><a href="#JZ-15-求整数对应的二进制数1的个数" class="headerlink" title="JZ_15:求整数对应的二进制数1的个数"></a>JZ_15:求整数对应的二进制数1的个数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> JZ_15;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JZ_15</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 &#x27;1&#x27; 的个数（也被称为 汉明重量).）。 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Solution15 solution15 = <span class="keyword">new</span> Solution15();</span><br><span class="line">        <span class="keyword">int</span> ret = solution15.hammingWeight(<span class="number">11</span>);</span><br><span class="line">        System.out.println(ret);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution15</span> </span>&#123;</span><br><span class="line">    <span class="comment">// you need to treat n as an unsigned value</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/* 循环检查二进制位 */</span></span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">0</span>; i &lt; <span class="number">32</span>; i++)&#123;</span><br><span class="line">            <span class="comment">// &amp;是按位与运算，1 &lt;&lt; i是将1左移i位。如果n与左移之后的1按位相与之后为1的话，说明第i位肯定是个1。</span></span><br><span class="line">            <span class="keyword">if</span> ((n &amp; (<span class="number">1</span> &lt;&lt; i )) != <span class="number">0</span>)&#123;</span><br><span class="line">                ret++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="JZ-17-输出n位数的递增数组"><a href="#JZ-17-输出n位数的递增数组" class="headerlink" title="JZ_17:输出n位数的递增数组"></a>JZ_17:输出n位数的递增数组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> JZ_17;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JZ_17_from1ton_digitnumber</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Solution17 solution17 = <span class="keyword">new</span> Solution17();</span><br><span class="line">        <span class="keyword">int</span>[] array_sum = solution17.printNumbers(<span class="number">4</span>);</span><br><span class="line">        System.out.println(array_sum.length);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution17</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] printNumbers(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">9</span>;</span><br><span class="line">        <span class="keyword">int</span> incerment = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">1</span>; i&lt;n; i++)&#123;</span><br><span class="line">            <span class="comment">// 9+10*9+100*9</span></span><br><span class="line">            sum = sum + incerment*<span class="number">9</span>;</span><br><span class="line">            incerment = incerment * <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] array_sum = <span class="keyword">new</span> <span class="keyword">int</span>[sum];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">0</span>; i&lt; sum ;i++)&#123;</span><br><span class="line">            array_sum[i] = i+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array_sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="数组初始化及输出"><a href="#数组初始化及输出" class="headerlink" title="数组初始化及输出"></a>数组初始化及输出</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 静态初始化</span></span><br><span class="line">String[] name = <span class="keyword">new</span> String[]&#123;<span class="string">&quot;PPT&quot;</span>, <span class="string">&quot;WORD&quot;</span>, <span class="string">&quot;EXCEL&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="comment">//动态初始化</span></span><br><span class="line"><span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">999</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组的遍历打印的三种方法</span></span><br><span class="line"><span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="comment">// 传统的for循环</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length;  i++)&#123;</span><br><span class="line">    System.out.println(array[i]);&#125;</span><br><span class="line"><span class="comment">// for each</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> a:array)&#123;</span><br><span class="line">    System.out.println(a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// toString方法</span></span><br><span class="line">System.out.println(Arrays.toString(array));  <span class="comment">//需要import java.util.Arrays;</span></span><br></pre></td></tr></table></figure>

<h3 id="JZ-21-调整数组顺序使奇数位于偶数前面"><a href="#JZ-21-调整数组顺序使奇数位于偶数前面" class="headerlink" title="JZ_21:调整数组顺序使奇数位于偶数前面"></a>JZ_21:调整数组顺序使奇数位于偶数前面</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> JZ_21;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JZ_21_ODDBeforeEVEN</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。 输入：nums =</span></span><br><span class="line"><span class="comment">     * [1,2,3,4] 输出：[1,3,2,4] 注：[3,1,2,4] 也是正确的答案之一。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">2</span> &#125;;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> Solution();</span><br><span class="line">        <span class="keyword">int</span>[] newnums = solution.exchange(nums);</span><br><span class="line">        System.out.println(Arrays.toString(newnums));</span><br><span class="line">        System.out.println(<span class="number">1</span>&amp;<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] exchange(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>, tem;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left] % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">                left++;</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right] % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">                right--;</span><br><span class="line">            tem = nums[left];</span><br><span class="line">            nums[left] = nums[right];</span><br><span class="line">            nums[right] = tem;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="JZ-28-顺时针打印数组"><a href="#JZ-28-顺时针打印数组" class="headerlink" title="JZ_28:顺时针打印数组"></a>JZ_28:顺时针打印数组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> JZ_29;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JZ_29_printmatrix</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。 输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]</span></span><br><span class="line"><span class="comment">     * 输出：[1,2,3,6,9,8,7,4,5]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] matrix = <span class="keyword">new</span> <span class="keyword">int</span>[][] &#123; &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;, &#123; <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> &#125;, &#123; <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> &#125; &#125;;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> Solution();</span><br><span class="line">        <span class="keyword">int</span>[] m_arr = solution.spiralOrder(matrix);</span><br><span class="line">        System.out.println(Arrays.toString(m_arr));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] spiralOrder(<span class="keyword">int</span>[][] matrix) &#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = matrix[<span class="number">0</span>].length - <span class="number">1</span>, t = <span class="number">0</span>, b = matrix.length - <span class="number">1</span>, x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[(r+<span class="number">1</span>)*(b+<span class="number">1</span>)];</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; i++)</span><br><span class="line">                res[x++] = matrix[t][i]; <span class="comment">// 从左到右, t代表行数</span></span><br><span class="line">            <span class="keyword">if</span> (++t &gt; b)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = t; i &lt;= b; i++)</span><br><span class="line">                res[x++] = matrix[i][r]; <span class="comment">// top to bottom，r代表列</span></span><br><span class="line">            <span class="keyword">if</span> (l &gt; --r)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = r; i &gt;= l; i--)</span><br><span class="line">                res[x++] = matrix[b][i]; <span class="comment">// right to left.</span></span><br><span class="line">            <span class="keyword">if</span> (t &gt; --b)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = b; i &gt;= t; i--)</span><br><span class="line">                res[x++] = matrix[i][l]; <span class="comment">// bottom to top.</span></span><br><span class="line">            <span class="keyword">if</span> (++l &gt; r)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="JZ-40-TopK问题"><a href="#JZ-40-TopK问题" class="headerlink" title="JZ_40_TopK问题"></a>JZ_40_TopK问题</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> JZ_40;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JZ_40_LeastNums</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 输入整数数组 arr ，找出其中最小的 k 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">2</span> &#125;;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> Solution();</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">5</span>;</span><br><span class="line">        <span class="comment">// int[] LeastKnums = solution.getLeastNumbers(arr, k);</span></span><br><span class="line">        <span class="comment">// System.out.println(Arrays.toString(LeastKnums));</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 快速排序方法</span></span><br><span class="line">        <span class="keyword">int</span>[] LeastKnumsqk = solution.getLeastNumbersqk(arr, k);</span><br><span class="line">        System.out.println(Arrays.toString(LeastKnumsqk));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 随机数生成 */</span></span><br><span class="line">        System.out.println(<span class="string">&quot;随机数&quot;</span> + (<span class="keyword">int</span>) (<span class="number">1</span> + Math.random() * <span class="number">10</span>));</span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">int</span> r1 = random.nextInt(<span class="number">100</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;util.Random()生成的随机数：&quot;</span> + r1);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] getLeastNumbers(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k) &#123;</span><br><span class="line"></span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line">        <span class="keyword">int</span>[] LeastKnums = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            LeastKnums[i] = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> LeastKnums;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] getLeastNumbersqk(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        randomizedSelected(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>, k);</span><br><span class="line">        <span class="keyword">int</span>[] vec = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">            vec[i] = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vec;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">randomizedSelected</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= r) &#123;</span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">// 是个空数组或者？</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> pos = randomizedPartition(arr, l, r); <span class="comment">// 先取一个随机数快速排序一趟， l=0, r = arr.length-1</span></span><br><span class="line">        <span class="keyword">int</span> num = pos - l + <span class="number">1</span>; <span class="comment">// 算一下排好序的数前边有多少个数</span></span><br><span class="line">        <span class="keyword">if</span> (k == num) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (k &lt; num) &#123;</span><br><span class="line">            randomizedSelected(arr, l, pos - <span class="number">1</span>, k);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            randomizedSelected(arr, pos + <span class="number">1</span>, r, k - num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">randomizedPartition</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="keyword">new</span> Random().nextInt(r - l + <span class="number">1</span>) + l; <span class="comment">// 生成l~r之间的随机数</span></span><br><span class="line">        swap(nums, r, i); <span class="comment">// 将随机位置的数与右端的数进行交换</span></span><br><span class="line">        <span class="keyword">return</span> partition(nums, l, r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一趟快速排序，</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pivot = nums[r];</span><br><span class="line">        <span class="keyword">int</span> i = l - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = l; j &lt;= r - <span class="number">1</span>; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] &lt;= pivot) &#123;</span><br><span class="line">                i = i + <span class="number">1</span>;</span><br><span class="line">                swap(nums, i, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums, i + <span class="number">1</span>, r);</span><br><span class="line">        <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 交换两个元素的位置</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="JZ-42-最大连续子数组的和"><a href="#JZ-42-最大连续子数组的和" class="headerlink" title="JZ_42:最大连续子数组的和"></a>JZ_42:最大连续子数组的和</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> JZ_42;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JZ_42_MAXSubArr</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; -<span class="number">2</span>, <span class="number">1</span>, -<span class="number">3</span>, <span class="number">4</span>, -<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, -<span class="number">5</span>, <span class="number">4</span> &#125;;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> Solution();</span><br><span class="line">        <span class="keyword">int</span> maxans = solution.MaxSubArray(arr);</span><br><span class="line">        System.out.println(maxans);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">MaxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pre = <span class="number">0</span>, MaxAns = nums[<span class="number">0</span>]; <span class="comment">// pre；maxans存当前连续</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x : nums) &#123;</span><br><span class="line">            pre = Math.max(pre + x, x);</span><br><span class="line">            MaxAns = Math.max(pre, MaxAns);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> MaxAns;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>包括HashMap, TreeMap, Hashtable, SortedMap, Collection, Set</p>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>size next() hasNext() keySet（）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap; <span class="comment">//导入需要的包</span></span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">basicusage</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;lixian&quot;</span>, <span class="number">24</span>); <span class="comment">//关联键值对</span></span><br><span class="line">        map.put(<span class="string">&quot;zhangsan&quot;</span>, <span class="number">25</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;当前Map的大小是：&quot;</span> + map.size()); <span class="comment">//输出大小</span></span><br><span class="line">        System.out.println(<span class="string">&quot;当前Map是否为空：&quot;</span> + map.isEmpty()); <span class="comment">//输出map是否为空</span></span><br><span class="line">        System.out.println(<span class="string">&quot;当前Map是否存在键“lixian”：&quot;</span> + map.containsKey(<span class="string">&quot;lixian&quot;</span>)); <span class="comment">//判断是否存在某一个键</span></span><br><span class="line">        System.out.println(<span class="string">&quot;”lixian“对应的value是：&quot;</span> + map.get(<span class="string">&quot;lixian&quot;</span>)); <span class="comment">//获得键对应的值</span></span><br><span class="line">        System.out.println(map.remove(<span class="string">&quot;zhangsan&quot;</span>)); <span class="comment">//删除指定的键值对</span></span><br><span class="line">        Map map2 = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map2.putAll(map); <span class="comment">//将所有的映射关系从map添加到map2</span></span><br><span class="line">        System.out.println(<span class="string">&quot;map HashMap:&quot;</span> + map);</span><br><span class="line">        System.out.println(<span class="string">&quot;putAll之后的map2 HashMap:&quot;</span> + map2);</span><br><span class="line">        map.clear();</span><br><span class="line">        System.out.println(<span class="string">&quot;After clear map HashMap:&quot;</span> + map);</span><br><span class="line">        map.put(<span class="string">&quot;lixian&quot;</span>, <span class="number">24</span>); </span><br><span class="line">        map.put(<span class="string">&quot;liudehua&quot;</span>, <span class="number">56</span>);</span><br><span class="line">        map.put(<span class="string">&quot;zhoujielun&quot;</span>, <span class="number">40</span>);</span><br><span class="line">        System.out.println(map.keySet()); <span class="comment">//返回所有键的集合</span></span><br><span class="line">        <span class="comment">// 遍历Map</span></span><br><span class="line">        System.out.println(<span class="string">&quot;\n遍历Map得到：&quot;</span>);</span><br><span class="line">        Set&lt;String&gt; keys = map.keySet();</span><br><span class="line">        <span class="comment">// 获取迭代器</span></span><br><span class="line">        <span class="comment">/* 迭代器的常用内部方法</span></span><br><span class="line"><span class="comment">        next()</span></span><br><span class="line"><span class="comment">        hasNext()</span></span><br><span class="line"><span class="comment">        remove()</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Iterator&lt;String&gt; st = keys.iterator();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (String key:keys)&#123;</span><br><span class="line">            String st1 = key;</span><br><span class="line">            Integer value = map.get(st1);</span><br><span class="line">            System.out.println(<span class="string">&quot;valus:&quot;</span> + value);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;*******迭代器学习&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (st.hasNext())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;使用迭代器输出Map: &quot;</span> + st.next());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">当前Map的大小是：2</span></span><br><span class="line"><span class="comment">当前Map是否为空：false</span></span><br><span class="line"><span class="comment">当前Map是否存在键“lixian”：true</span></span><br><span class="line"><span class="comment">”lixian“对应的value是：24</span></span><br><span class="line"><span class="comment">25</span></span><br><span class="line"><span class="comment">map HashMap:&#123;lixian=24&#125;</span></span><br><span class="line"><span class="comment">putAll之后的map2 HashMap:&#123;lixian=24&#125;</span></span><br><span class="line"><span class="comment">After clear map HashMap:&#123;&#125;</span></span><br><span class="line"><span class="comment">[lixian, zhoujielun, liudehua]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">遍历Map得到：</span></span><br><span class="line"><span class="comment">valus:24</span></span><br><span class="line"><span class="comment">valus:40</span></span><br><span class="line"><span class="comment">valus:56</span></span><br><span class="line"><span class="comment">*******迭代器学习</span></span><br><span class="line"><span class="comment">使用迭代器输出Maplixian</span></span><br><span class="line"><span class="comment">使用迭代器输出Mapzhoujielun</span></span><br><span class="line"><span class="comment">使用迭代器输出Mapliudehua</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="TreeNode"><a href="#TreeNode" class="headerlink" title="TreeNode"></a>TreeNode</h3><ul>
<li>每个节点要么是黑色，要么是红色。（节点非黑即红）</li>
<li>根节点是黑色。</li>
<li>每个叶子节点（NIL）是黑色。</li>
<li>如果一个节点是红色的，则它的子节点必须是黑色的。（也就是说父子节点不能同时为红色）</li>
<li>从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。（这一点是平衡的关键）</li>
</ul>
<h3 id="JZ07-重建二叉树（递归形式）-evergreen-tree"><a href="#JZ07-重建二叉树（递归形式）-evergreen-tree" class="headerlink" title="JZ07:重建二叉树（递归形式）:evergreen_tree:"></a>JZ07:重建二叉树（递归形式）:evergreen_tree:</h3><p>已知前序遍历、中序遍历，输出树</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//递归的思路</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, Integer&gt; indexMap;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">myBuildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder, <span class="keyword">int</span> preorder_left, <span class="keyword">int</span> preorder_right, <span class="keyword">int</span> inorder_left, <span class="keyword">int</span> inorder_right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (preorder_left &gt; preorder_right)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">//两端为空，即没有树了</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 根节点:先序遍历的第一个就是</span></span><br><span class="line">        <span class="keyword">int</span> preorder_root = preorder_left;</span><br><span class="line">        <span class="keyword">int</span> inorder_root = indexMap.get(preorder[preorder_root]);</span><br><span class="line">        <span class="comment">//建立树的根节点</span></span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(preorder[preorder_root]);</span><br><span class="line">        <span class="comment">//左子树里面的结点数量</span></span><br><span class="line">        <span class="keyword">int</span> size_left_subtree = inorder_root-inorder_left;</span><br><span class="line">        <span class="comment">//递归构建左子树</span></span><br><span class="line">        root.left = myBuildTree(preorder, inorder, preorder_left+<span class="number">1</span>, preorder_left+size_left_subtree, inorder_left, inorder_root-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        root.right = myBuildTree(preorder, inorder, preorder_left+size_left_subtree+<span class="number">1</span>, preorder_right, inorder_root + <span class="number">1</span>, inorder_right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = preorder.length;</span><br><span class="line">        <span class="comment">//构造哈希映射，定位根节点</span></span><br><span class="line">        indexMap = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            indexMap.put(inorder[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> myBuildTree(preorder, inorder, <span class="number">0</span>, n-<span class="number">1</span>, <span class="number">0</span>, n-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="JZ27-二叉树的镜像翻转"><a href="#JZ27-二叉树的镜像翻转" class="headerlink" title="JZ27:二叉树的镜像翻转"></a>JZ27:二叉树的镜像翻转</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node. public class TreeNode &#123; int val; TreeNode</span></span><br><span class="line"><span class="comment"> * left; TreeNode right; TreeNode(int x) &#123; val = x; &#125; &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/* 请完成一个函数，输入一个二叉树，该函数输出它的镜像。</span></span><br><span class="line"><span class="comment">输入：root = [4,2,7,1,3,6,9]</span></span><br><span class="line"><span class="comment">输出：[4,7,2,9,6,3,1] */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">mirrorTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        TreeNode left = mirrorTree(root.left);</span><br><span class="line">        TreeNode right = mirrorTree(root.right);</span><br><span class="line">        root.left = right;</span><br><span class="line">        root.right = left;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="JZ-28-判断二叉树是不是对称的"><a href="#JZ-28-判断二叉树是不是对称的" class="headerlink" title="JZ_28:判断二叉树是不是对称的"></a>JZ_28:判断二叉树是不是对称的</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。</span></span><br><span class="line"><span class="comment">例如，二叉树 [1,2,2,3,4,4,3] 是对称的。 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root == <span class="keyword">null</span>? <span class="keyword">true</span> : recur(root.left, root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">recur</span><span class="params">(TreeNode L, TreeNode R)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (L== <span class="keyword">null</span> &amp;&amp; R == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>; <span class="comment">//只有单个结点，属于对称树</span></span><br><span class="line">        <span class="keyword">if</span> (L==<span class="keyword">null</span> || R==<span class="keyword">null</span> || L.val ! = R.val) <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">//</span></span><br><span class="line">        <span class="keyword">return</span> recur(L.left, R.right) &amp;&amp; recur(L.right, R.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h2><h3 id="Stack的初始化及基本操作"><a href="#Stack的初始化及基本操作" class="headerlink" title="Stack的初始化及基本操作"></a>Stack的初始化及基本操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义方式1</span></span><br><span class="line">Stack&lt;Integer&gt; A, B;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MinStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    B = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义方式2</span></span><br><span class="line">Stack&lt;Integer&gt; A=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//基本操作</span></span><br><span class="line">Stack&lt;Integer&gt; test = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">test.push(<span class="number">2</span>);</span><br><span class="line">test.push(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">int</span> peek = test.peek();</span><br><span class="line">System.out.println(<span class="string">&quot;当前的栈顶元素是：&quot;</span>+peek);</span><br><span class="line">test.pop();</span><br><span class="line">Integer peek1 = test.peek();</span><br><span class="line">System.out.println(<span class="string">&quot;当前的栈顶元素是：&quot;</span>+peek1);</span><br><span class="line">System.out.println(<span class="string">&quot;当前栈判空情况：&quot;</span>+test.empty());</span><br></pre></td></tr></table></figure>



<h3 id="JZ06-从尾到头打印链表-last-quarter-moon"><a href="#JZ06-从尾到头打印链表-last-quarter-moon" class="headerlink" title="JZ06:从尾到头打印链表:last_quarter_moon:"></a>JZ06:从尾到头打印链表:last_quarter_moon:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">int</span>[] reversePrint(ListNode head) &#123;</span><br><span class="line">        <span class="comment">//初始化一个栈</span></span><br><span class="line">        Stack&lt;ListNode&gt; stack = <span class="keyword">new</span> Stack&lt;ListNode&gt;();</span><br><span class="line">        <span class="comment">//将链表的头赋值给temp，将temp入栈，并且遍历链表后续的数据</span></span><br><span class="line">        ListNode temp = head;</span><br><span class="line">        <span class="keyword">while</span> (temp != <span class="keyword">null</span>)&#123;</span><br><span class="line">            stack.push(temp);</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> size = stack.size();</span><br><span class="line">        <span class="keyword">int</span>[] print = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;size; i++)&#123;</span><br><span class="line">            print[i] = stack.pop().val;<span class="comment">// 栈的值赋给print数组</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> print;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="JZ-30-O-1-的复杂度输出栈中的最小值"><a href="#JZ-30-O-1-的复杂度输出栈中的最小值" class="headerlink" title="JZ_30:$O(1)$的复杂度输出栈中的最小值"></a>JZ_30:$O(1)$的复杂度输出栈中的最小值</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> JZ_30;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JZ30_mininStack</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MinStack minStack = <span class="keyword">new</span> MinStack();</span><br><span class="line">        minStack.push(<span class="number">1</span>);</span><br><span class="line">        minStack.push(<span class="number">2</span>);</span><br><span class="line">        minStack.push(<span class="number">4</span>);</span><br><span class="line">        minStack.push(<span class="number">2</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;当前minStack栈的最小值是： &quot;</span> + minStack.min());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Stack&lt;Integer&gt; A, B;</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MinStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        A = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        B = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        A.add(x);</span><br><span class="line">        <span class="keyword">if</span>(B.empty() || B.peek() &gt;= x)</span><br><span class="line">            B.add(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(A.pop().equals(B.peek()))</span><br><span class="line">            B.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> A.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> B.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MinStack object will be instantiated and called as such: MinStack obj =</span></span><br><span class="line"><span class="comment"> * new MinStack(); obj.push(x); obj.pop(); int param_3 = obj.top(); int param_4</span></span><br><span class="line"><span class="comment"> * = obj.min();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>



<h2 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h2><h3 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h3><table>
<thead>
<tr>
<th align="center">Method：抛出异常/为空时抛出null,false</th>
<th align="center">Description</th>
<th>等效的Deque()</th>
<th>对应的栈方法</th>
</tr>
</thead>
<tbody><tr>
<td align="center">add(e)/offer(e)</td>
<td align="center">插入</td>
<td>addLast(e)/offerLast(e)</td>
<td></td>
</tr>
<tr>
<td align="center">remove()/poll()</td>
<td align="center">删除</td>
<td>removeFirst()/pollFirst()</td>
<td>pop()</td>
</tr>
<tr>
<td align="center">element()/peek()</td>
<td align="center">检查(返回队头)</td>
<td>getFirst()/peekFirst()</td>
<td>peek()</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td>addFirst(e)</td>
<td>push(e)</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="JZ09-用两个栈实现队列"><a href="#JZ09-用两个栈实现队列" class="headerlink" title="JZ09:用两个栈实现队列"></a>JZ09:用两个栈实现队列</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CQueue</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">    思路：两个栈，一个负责支持插入操作，一个负责删除操作；</span></span><br><span class="line"><span class="comment">    第一个栈的底部元素是最后插入的元素，第一个栈的顶部元素是下一个待删除的元素；</span></span><br><span class="line"><span class="comment">    第二个栈维护待删除的元素，如果该栈为空，则将第一个栈的栈顶元素弹出到第二个栈里面，则第二个栈的元素的顺序就是待删除元素的顺序。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    Deque&lt;Integer&gt; stack1;</span><br><span class="line">    Deque&lt;Integer&gt; stack2;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stack1 = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        stack2 = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">appendTail</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        stack1.push(value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">deleteHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果栈2为空，将栈1的元素出栈并且入栈2,</span></span><br><span class="line">        <span class="keyword">if</span> (stack2.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(!stack1.isEmpty())&#123;</span><br><span class="line">                stack2.push(stack1.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将栈2元素出栈</span></span><br><span class="line">        <span class="keyword">if</span> (stack2.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> deleteItem = stack2.pop();</span><br><span class="line">            <span class="keyword">return</span> deleteItem;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your CQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * CQueue obj = new CQueue();</span></span><br><span class="line"><span class="comment"> * obj.appendTail(value);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj.deleteHead();</span></span><br><span class="line"><span class="comment"> 输入</span></span><br><span class="line"><span class="comment">[&quot;CQueue&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;]</span></span><br><span class="line"><span class="comment">[[],[3],[],[],[]]</span></span><br><span class="line"><span class="comment">输出</span></span><br><span class="line"><span class="comment">[null,null,3,-1,-1]</span></span><br><span class="line"><span class="comment">预期结果</span></span><br><span class="line"><span class="comment">[null,null,3,-1,-1]</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h2 id="ListNode"><a href="#ListNode" class="headerlink" title="ListNode"></a>ListNode</h2><h3 id="JZ-18-删除链表的结点"><a href="#JZ-18-删除链表的结点" class="headerlink" title="JZ_18:删除链表的结点"></a>JZ_18:删除链表的结点</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> JZ_18;</span><br><span class="line"><span class="comment">/* 实现一个ListNode并且插入删除等基本操作 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JZ_18delchainlistnode</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; <span class="number">4</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">2</span> &#125;;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> Solution();</span><br><span class="line">        ListNode myListNode = solution.initLN(arr); <span class="comment">// 初始化LN</span></span><br><span class="line">        System.out.println(<span class="string">&quot;初始化之后的LN是：&quot;</span>);</span><br><span class="line">        solution.print(myListNode); <span class="comment">// 打印LN</span></span><br><span class="line"></span><br><span class="line">        solution.deleteNode(myListNode, <span class="number">5</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;删除结点5之后的LN是：&quot;</span>);</span><br><span class="line">        solution.print(myListNode); <span class="comment">// 打印LN</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// ListNode valnode = new ListNode(4);</span></span><br><span class="line">        <span class="comment">/* 在最尾部插入不行，看看含义 */</span></span><br><span class="line">        solution.insertNode(myListNode, <span class="number">4</span>, <span class="number">10</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;插入结点10之后的LN是：&quot;</span>);</span><br><span class="line">        solution.print(myListNode); <span class="comment">// 打印LN</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list. public class ListNode &#123; int val; ListNode</span></span><br><span class="line"><span class="comment"> * next; ListNode(int x) &#123; val = x; &#125; &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 从数组初始化一个ListNode */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">initLN</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/* ListNode的初始化 */</span></span><br><span class="line">        ListNode nextNode; <span class="comment">// 指示当前结点</span></span><br><span class="line">        ListNode head = <span class="keyword">new</span> ListNode(arr[<span class="number">0</span>]);</span><br><span class="line">        nextNode = head; <span class="comment">// 指向头结点</span></span><br><span class="line">        <span class="comment">// 追加结点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            ListNode node = <span class="keyword">new</span> ListNode(arr[i]);</span><br><span class="line">            nextNode.next = node;</span><br><span class="line">            nextNode = nextNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 再指向头结点</span></span><br><span class="line">        nextNode = head;</span><br><span class="line">        <span class="keyword">return</span> nextNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 打印输出ListNode所有节点 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(ListNode listNode)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建链表节点</span></span><br><span class="line">        <span class="keyword">while</span> (listNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;结点:&quot;</span> + listNode.val);</span><br><span class="line">            listNode = listNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 按值删除结点 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteNode</span><span class="params">(ListNode head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head.val == val)</span><br><span class="line">            <span class="keyword">return</span> head.next; <span class="comment">// 如果要删除的结点是头结点</span></span><br><span class="line">        ListNode pre = head, cur = head.next;</span><br><span class="line">        <span class="comment">// 如果链表的值不是需要删除的，那么就是pre指向当前，cur指向下一个</span></span><br><span class="line">        <span class="comment">// 如果发现了这个值是要删除的或者是遍历完了整个LN，就跳出循环，此时cur指向的就是目的结点或者是空，如果指向目的节点就令前一个的next指向cur的next进行删除。</span></span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span> &amp;&amp; cur.val != val) &#123;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cur != <span class="keyword">null</span>)</span><br><span class="line">            pre.next = cur.next;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 按值插入节点，在valnode之后插入值aim */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">insertNode</span><span class="params">(ListNode head, <span class="keyword">int</span> val, <span class="keyword">int</span> aim)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ListNode valnode = new ListNode(val);</span></span><br><span class="line">        ListNode aimnode = <span class="keyword">new</span> ListNode(aim);</span><br><span class="line">        ListNode pre = head, cur = head.next;</span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        <span class="keyword">if</span> (pre.val == val) &#123;</span><br><span class="line">            aimnode.next = head.next;</span><br><span class="line">            head.next = aimnode;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;正在遍历LN，pre值为：&quot;</span> + pre.val + <span class="string">&quot;当前cur值:&quot;</span> + cur.val);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (cur.val == val &amp;&amp; pre != <span class="keyword">null</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;正在插入结点aimnode，其值为：&quot;</span> + aimnode.val);</span><br><span class="line">                aimnode.next = cur.next; <span class="comment">// 新结点指向原来pre的下一个，也就是cur</span></span><br><span class="line">                <span class="comment">// aimnode.next = pre.next; //新结点指向pre的下一个</span></span><br><span class="line">                cur.next = aimnode; <span class="comment">// 新的cur指向新的结点</span></span><br><span class="line">            &#125;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = cur.next;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ListNode的定义</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123; <span class="comment">// 类名 ：Java类就是一种自定义的数据结构</span></span><br><span class="line">    <span class="keyword">int</span> val; <span class="comment">// 数据 ：节点数据</span></span><br><span class="line">    ListNode next; <span class="comment">// 对象 ：引用下一个节点对象。在Java中没有指针的概念，Java中的引用和C语言的指针类似</span></span><br><span class="line"></span><br><span class="line">    ListNode(<span class="keyword">int</span> val) &#123; <span class="comment">// 构造方法 ：构造方法和类名相同</span></span><br><span class="line">        <span class="keyword">this</span>.val = val; <span class="comment">// 把接收的参数赋值给当前类的val变量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="JZ-22-输出链表倒数第k到最后"><a href="#JZ-22-输出链表倒数第k到最后" class="headerlink" title="JZ_22:输出链表倒数第k到最后"></a>JZ_22:输出链表倒数第k到最后</h3><p><strong>链表的定义、由数组生成链表与上个相同，这里只写函数实现</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> JZ_22;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 例如，一个链表有 6 个节点，从头节点开始，它们的值依次是 1、2、3、4、5、6。这个链表的倒数第 3 个节点是值为 4 的节点。</span></span><br><span class="line"><span class="comment">     * 给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 k = 2.</span></span><br><span class="line"><span class="comment">     * 返回链表 4-&gt;5.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list. public class ListNode &#123; int val; ListNode</span></span><br><span class="line"><span class="comment"> * next; ListNode(int x) &#123; val = x; &#125; &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getKthFromEnd0</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/* 两个思路，一个是顺序查到第n-k个结点即倒数第k个结点 */</span></span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            len = len +<span class="number">1</span>;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// System.out.println(len);</span></span><br><span class="line">        ListNode node = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (node = head; len&gt;k; len--)&#123;</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getKthFromEnd1</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/* 两个思路，另一个是快慢指针 */</span></span><br><span class="line">        ListNode fast = head, slow = head;</span><br><span class="line">        <span class="keyword">while</span>(fast!=<span class="keyword">null</span> &amp;&amp; k&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            k--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(fast!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="JZ-24-逆序输出链表"><a href="#JZ-24-逆序输出链表" class="headerlink" title="JZ_24:逆序输出链表"></a>JZ_24:逆序输出链表</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> JZ_24;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。</span></span><br><span class="line"><span class="comment">     * 示例:</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL 输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list. public class ListNode &#123; int val; ListNode</span></span><br><span class="line"><span class="comment"> * next; ListNode(int x) &#123; val = x; &#125; &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        ListNode pre = head, cur = head.next;</span><br><span class="line">        <span class="comment">//先把第一个结点让它指向null，并更新pre, cur</span></span><br><span class="line">        ListNode temcurnex = cur.next;</span><br><span class="line">        cur.next = pre;</span><br><span class="line">        pre = cur;</span><br><span class="line">        pre.next.next = <span class="keyword">null</span>;</span><br><span class="line">        cur = temcurnex;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ListNode curnex = cur.next;</span><br><span class="line">            cur.next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = curnex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="JZ-25-合并两个递增链表"><a href="#JZ-25-合并两个递增链表" class="headerlink" title="JZ_25:合并两个递增链表"></a>JZ_25:合并两个递增链表</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> JZ_25;</span><br><span class="line"><span class="comment">/* 输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。</span></span><br><span class="line"><span class="comment">示例1：</span></span><br><span class="line"><span class="comment">输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4</span></span><br><span class="line"><span class="comment">输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 新建一个链表用来存数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        ListNode dum = <span class="keyword">new</span> ListNode(<span class="number">0</span>), cur = dum;</span><br><span class="line">        <span class="comment">// 将l1插入到l2</span></span><br><span class="line">        <span class="comment">// 刚开始cur指向的是dum，后续，cur指向比较小的那一个链表；如果有一个链表遍历完了，就把剩下的链表追加到dum链表。</span></span><br><span class="line">        <span class="keyword">while</span> (l1 != <span class="keyword">null</span> &amp;&amp; l2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">/* 更新dum链表，选择val小的结点接到dum链表上边 */</span></span><br><span class="line">            <span class="keyword">if</span> (l1.val &lt; l2.val) &#123;</span><br><span class="line">                cur.next = l1;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur.next = l2;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next; <span class="comment">// 让cur指向dum链表最新的结点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 直接把最后非空的那个链表给接过来</span></span><br><span class="line">        cur.next = l1 != <span class="keyword">null</span> ? l1 : l2;</span><br><span class="line">        <span class="keyword">return</span> dum.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><h3 id="List基础"><a href="#List基础" class="headerlink" title="List基础"></a>List基础</h3><h4 id="初始化及打印"><a href="#初始化及打印" class="headerlink" title="初始化及打印"></a>初始化及打印</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; innerList = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line"><span class="keyword">int</span> [] loc_nums = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>,<span class="number">6</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i: loc_nums)&#123;</span><br><span class="line">    innerList.add(i);</span><br><span class="line">    <span class="comment">// System.out.println(i);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印：通过迭代器</span></span><br><span class="line">Iterator loc_it = innerList.iterator();</span><br><span class="line"><span class="keyword">while</span>(loc_it.hasNext())&#123;</span><br><span class="line">    System.out.println(loc_it.next());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过for each  loc </span></span><br><span class="line"><span class="keyword">for</span> (Integer loc:innerList)&#123;</span><br><span class="line">    System.out.println(loc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="List-lt-List-lt-Integer-gt-gt"><a href="#List-lt-List-lt-Integer-gt-gt" class="headerlink" title="List&lt;List&lt;Integer&gt;&gt;"></a>List&lt;List&lt;Integer&gt;&gt;</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化</span></span><br><span class="line">List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">List&lt;List&lt;Integer&gt;&gt;list =<span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 添加list的层和值 */</span></span><br><span class="line"><span class="comment">/* 方法一 */</span></span><br><span class="line">list.add(<span class="keyword">new</span> LinkedList&lt;&gt;());  <span class="comment">//先添加层数</span></span><br><span class="line">list.get(<span class="number">0</span>).add(<span class="number">1</span>);          <span class="comment">//后在指定层数进行添值:list.get(layers).add(value);</span></span><br><span class="line">list.add(<span class="keyword">new</span> LinkedList&lt;&gt;());</span><br><span class="line">list.get(<span class="number">1</span>).add(<span class="number">11</span>);</span><br><span class="line">list.get(<span class="number">1</span>).add(<span class="number">12</span>);  <span class="comment">//插入第layers+1层的结尾</span></span><br><span class="line">list.get(<span class="number">1</span>).add(<span class="number">0</span>,<span class="number">13</span>);<span class="comment">//插入第layers+1层的开头</span></span><br><span class="line"><span class="comment">/* 方法二 */</span></span><br><span class="line">list.add(<span class="keyword">new</span> LinkedList&lt;&gt;(Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>)));</span><br><span class="line"><span class="comment">// list.get(2).add(31);//注明：这种表达是错误的，第三层已经由Arrays.asList赋值，无法使用list.get(2).add(31)这个语句</span></span><br><span class="line">         </span><br><span class="line"><span class="comment">/* 输出list的层数 */</span></span><br><span class="line">System.out.println(<span class="string">&quot;list的层数为: &quot;</span> + list.size());</span><br><span class="line"></span><br><span class="line"><span class="comment">/*list元素输出*/</span></span><br><span class="line">System.out.println(<span class="string">&quot;方法一：输出list元素&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">    System.out.println(Arrays.toString(list.get(i).toArray()));</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;方法二：输出list元素&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">    List&lt;Integer&gt; item = list.get(i);      <span class="comment">//item存第i+1层的所有元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; item.size(); j++) &#123;</span><br><span class="line">        System.out.print(item.get(j)+<span class="string">&quot;,&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* list元素的删除 */</span></span><br><span class="line">list.remove(<span class="number">1</span>);<span class="comment">//list.remove(i)删除第i+1层所有元素</span></span><br><span class="line">list.get(<span class="number">1</span>).remove(<span class="number">0</span>); <span class="comment">//list.get(i).remove(j)删除第i+1层的第j+1个元素</span></span><br><span class="line">System.out.println(<span class="string">&quot;输出删除后的结果&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">    System.out.println(Arrays.toString(list.get(i).toArray()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="JZ-32-从上到下打印二叉树"><a href="#JZ-32-从上到下打印二叉树" class="headerlink" title="JZ_32:从上到下打印二叉树"></a>JZ_32:从上到下打印二叉树</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="keyword">null</span>) queue.add(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">            List&lt;Integer&gt; tmp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = queue.size(); i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">                TreeNode node = queue.poll();</span><br><span class="line">                tmp.add(node.val);</span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="keyword">null</span>) queue.add(node.left);</span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="keyword">null</span>) queue.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><h3 id="String类的常用方法"><a href="#String类的常用方法" class="headerlink" title="String类的常用方法"></a>String类的常用方法</h3><ul>
<li>length() ：返回字符串长度</li>
<li>charAt() ：返回指定索引处的字符</li>
<li>substring() ：截取字符串</li>
<li>trim() ：去除字符串两端空白</li>
<li>split() ：分割字符串，返回一个分割后的字符串数组。</li>
<li>replace() ：字符串替换。</li>
<li>indexOf() ：返回指定字符的索引。</li>
<li>toLowerCase() ：将字符串转成小写字母。</li>
<li>toUpperCase() ：将字符串转成大写字符</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://naixil.github.io/2021/08/31/3Windows/W-2-WSL2%E5%AE%89%E8%A3%85Cuda%E5%8F%8ACudnn/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Li Xian">
      <meta itemprop="description" content="与遗忘作斗争">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LiXian's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/31/3Windows/W-2-WSL2%E5%AE%89%E8%A3%85Cuda%E5%8F%8ACudnn/" class="post-title-link" itemprop="url">Windows-2-WSL2安装Cuda及Cudnn.md</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-08-31 16:28:40" itemprop="dateCreated datePublished" datetime="2021-08-31T16:28:40+08:00">2021-08-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-09-02 11:24:09" itemprop="dateModified" datetime="2021-09-02T11:24:09+08:00">2021-09-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Windows/" itemprop="url" rel="index"><span itemprop="name">Windows</span></a>
                </span>
            </span>

          
            <span id="/2021/08/31/3Windows/W-2-WSL2%E5%AE%89%E8%A3%85Cuda%E5%8F%8ACudnn/" class="post-meta-item leancloud_visitors" data-flag-title="Windows-2-WSL2安装Cuda及Cudnn.md" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/08/31/3Windows/W-2-WSL2%E5%AE%89%E8%A3%85Cuda%E5%8F%8ACudnn/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/08/31/3Windows/W-2-WSL2%E5%AE%89%E8%A3%85Cuda%E5%8F%8ACudnn/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="1-环境"><a href="#1-环境" class="headerlink" title="1. 环境"></a>1. 环境</h1><ul>
<li>Windows10_insider_preview，必须得是insider_preview版本（OS内部版本开头数字要是20150以上），要不安装好了也是检测不到GPU的，已安装WSL2下的Ubuntu20.04</li>
<li>WSL2<ul>
<li>python3.8.5</li>
<li>pip 20.0.2</li>
<li>tensorflow==2.4.0</li>
</ul>
</li>
</ul>
<img src="/2021/08/31/3Windows/W-2-WSL2%E5%AE%89%E8%A3%85Cuda%E5%8F%8ACudnn/image-20210208213617002.png" alt="image-20210208213617002" style="zoom:33%;">



<h1 id="2-安装步骤"><a href="#2-安装步骤" class="headerlink" title="2. 安装步骤"></a>2. 安装步骤</h1><h2 id="2-1-驱动的安装"><a href="#2-1-驱动的安装" class="headerlink" title="2.1 驱动的安装"></a>2.1 驱动的安装</h2><p>WSL2的Nvidia驱动安装说明</p>
<blockquote>
<p>微软关于WSL安装英伟达驱动的说明：<br><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/win32/direct3d12/gpu-cuda-in-wsl">https://docs.microsoft.com/en-us/windows/win32/direct3d12/gpu-cuda-in-wsl</a></p>
</blockquote>
<ol>
<li><p>前提条件：</p>
<ol>
<li>Windows OS内部版本号&gt;20150</li>
<li>WSL2</li>
</ol>
</li>
<li><p>在<a target="_blank" rel="noopener" href="https://developer.nvidia.com/cuda/wsl/download">此网址</a>根据显卡类型选择驱动下载，在Windows下安装</p>
</li>
</ol>
<h2 id="2-2-Cuda-11-1安装"><a href="#2-2-Cuda-11-1安装" class="headerlink" title="2.2 Cuda-11.1安装"></a>2.2 Cuda-11.1安装</h2><p>编者按:<a target="_blank" rel="noopener" href="https://docs.nvidia.com/cuda/wsl-user-guide/index.html">官方给出的WSL安装Cuda教程</a>给出了两种安装方式,经过亲身实践apt-get方式安装的是行不通的,因为在执行<code>sh -c &#39;echo &quot;deb http://developer.download.nvidia.com/compute/cuda/repos/ubuntu2004/x86_64 /&quot; &gt; /etc/apt/sources.list.d/cuda.list&#39;</code>之后再执行<code>apt-get</code>的时候会报错<code>The repository http://developer.download.nvidia.com/compute/cuda/repos/ubuntu2004/x86_64 is not signed</code>以及<code>BAG SIG</code>错误,编者在网络搜索了很多方法(包括导入GPG公钥到<em>keyserver.ubuntu.com</em>等等方法)都是不可行的.</p>
<img src="/2021/08/31/3Windows/W-2-WSL2%E5%AE%89%E8%A3%85Cuda%E5%8F%8ACudnn/image-20210208215808957.png" alt="image-20210208215808957" style="zoom:50%;">
<img src="/2021/08/31/3Windows/W-2-WSL2%E5%AE%89%E8%A3%85Cuda%E5%8F%8ACudnn/image-20210705154349367.png" alt="image-20210208215808957" style="zoom:50%;">

<p>下文给出的是<strong>切实可行的办法</strong>,也就是通过runfile方法进行安装.</p>
<p>打开<a target="_blank" rel="noopener" href="https://developer.nvidia.com/cuda-11.1.0-download-archive?target_os=Linux&target_arch=x86_64&target_distro=WSLUbuntu&target_version=20&target_type=runfilelocal">这个网址</a>按照下图进行选择</p>
<img src="/2021/08/31/3Windows/W-2-WSL2%E5%AE%89%E8%A3%85Cuda%E5%8F%8ACudnn/image-20210208215949949.png" alt="image-20210208215949949" style="zoom:50%;">

<p>先在shell里面切换到ubuntu的Downloads文件夹,接着在Ubuntu的Shell里面输入:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https://developer.download.nvidia.com/compute/cuda/11.1.0/local_installers/cuda_11.1.0_455.23.05_linux.run </span><br><span class="line">sudo sh cuda_11.1.0_455.23.05_linux.run</span><br></pre></td></tr></table></figure>

<p>上面命令第一行会下载一个.run的文件到Downloads,第二行是进行安装.网络上其他教程可能会说在安装的时候不要选安装Driver的选项,但是实际操作过程中并没有让选择安装Driver的教程,猜想可能是因为cuda的版本(11.1)比较新,已经适配了WSL(毕竟在选择的网址那已经有了一个WSL-Ubuntu的选项).</p>
<p>安装完成之后在电脑的<code>/usr/local</code>目录下应该有一个cuda-11.1的文件夹(其中cuda那个是安装过程自动创建的软连接).</p>
<img src="/2021/08/31/3Windows/W-2-WSL2%E5%AE%89%E8%A3%85Cuda%E5%8F%8ACudnn/image-20210208220927510.png" alt="image-20210208220927510" style="zoom:50%;">

<p>接下来还需要配置环境变量,这里如果是自己的电脑建议直接在<code>/etc/profile</code>里面配置,省的开机后环境变量会失效或者是从bash切换到zsh的时候导致环境变量失效(编者就是因为安装之后又嫌弃WindowsTerminal的终端太难看,又弄的zsh-ohmyzsh-powerline什么的):</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export PATH=&#x27;$PATH:/usr/local/cuda-11.1/bin/:/usr/bin:/usr/local/bin:/usr/local/sbin:/usr/sbin:/sbin&#x27;</span><br><span class="line">export LD_LIBRARY_PATH=&quot;/usr/local/cuda-11.1/lib64:$LD_LIBRARY_PATH&quot;</span><br></pre></td></tr></table></figure>

<p>完毕之后输入<code>nvcc -V</code>应该显示如下信息.如果没有,那就是没安装成功,卸载重装重新走一遍上面的流程.</p>
<img src="/2021/08/31/3Windows/W-2-WSL2%E5%AE%89%E8%A3%85Cuda%E5%8F%8ACudnn/image-20210208221022268.png" alt="image-20210208221022268" style="zoom:50%;">

<h2 id="2-3-Cudnn安装"><a href="#2-3-Cudnn安装" class="headerlink" title="2.3 Cudnn安装"></a>2.3 Cudnn安装</h2><p>说是安装实际也不是,就是下载文件然后复制到对应的cuda的文件夹就是了.</p>
<p>网址:<a target="_blank" rel="noopener" href="https://developer.nvidia.com/rdp/cudnn-download">https://developer.nvidia.com/rdp/cudnn-download</a></p>
<p>上面的网址需要注册成为开发者才能下载.cudnn的版本一定要和cuda的版本对应.</p>
<img src="/2021/08/31/3Windows/W-2-WSL2%E5%AE%89%E8%A3%85Cuda%E5%8F%8ACudnn/image-20210208232414929.png" alt="image-20210208232414929" style="zoom:50%;">

<p>下载后得到的文件夹是<code>cudnn-11.2-linux-x64-v8.1.0.77.arj</code>,这里后缀名是arj,原因不详(我是在Windows下载的),但是可以直接把后缀改成tgz,之后移动到Ubuntu对应的文件夹(Windows的盘符比如说D盘在WSL-Ubuntu里面就是<code>/mnt/d/</code>),移动到Ubuntu的里面(此处我移动到了Ubuntu的Downloads文件夹,以下操作也是在Downloads文件夹下进行操作)就可以进行Cudnn文件的安装(其实是复制):</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf cudnn-11.2-linux-x64-v8.1.0.77.tgz</span><br><span class="line">sudo cp cuda/include/cudnn.h /usr/local/cuda-11.1/include/</span><br><span class="line">sudo cp cuda/lib64/libcudnn* /usr/local/cuda-11.1/lib64/</span><br><span class="line">sudo cp /usr/local/cuda-11.1/lib64/libcusolver.so.11 /usr/local/cuda-11.1/lib64/libcusolver.so.10</span><br><span class="line">sudo chmod +x /usr/local/cuda/include/cudnn.h</span><br><span class="line">sudo chmod +x /usr/local/cuda/lib64/libcudnn*</span><br></pre></td></tr></table></figure>

<p>这里<strong>一定要</strong>执行复制libcusolver.so.11的那行命令,不然cuda会无法正常工作报如下错误,找不到GPU.</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Could not load dynamic library &#x27;libcusolver.so.10&#x27;; dlerror: libcusolver.so.10: </span><br><span class="line">cannot open shared object file: No such file or directory; LD_LIBRARY_PATH: /usr/local/cuda-11.1/lib64</span><br></pre></td></tr></table></figure>

<p>至此,在Windows的WSL-Ubuntu下安装Cuda以及Cudnn已结束.以下代码可以验证GPU的存在(需要已经安装tensorflow).</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line">devices = tf.config.list_physical_devices()</span><br><span class="line"><span class="built_in">print</span>(devices)</span><br></pre></td></tr></table></figure>

<p>输出:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[PhysicalDevice(name=<span class="string">&#x27;/physical_device:CPU:0&#x27;</span>, device_type=<span class="string">&#x27;CPU&#x27;</span>), PhysicalDevice(name=<span class="string">&#x27;/physical_device:GPU:0&#x27;</span>, device_type=<span class="string">&#x27;GPU&#x27;</span>)]</span><br></pre></td></tr></table></figure>



<h1 id="几处容易踩坑的地方"><a href="#几处容易踩坑的地方" class="headerlink" title="几处容易踩坑的地方"></a>几处容易踩坑的地方</h1><h2 id="1-环境变量的配置"><a href="#1-环境变量的配置" class="headerlink" title="1 环境变量的配置"></a>1 环境变量的配置</h2><h3 id="1-1-重启后nvcc-V显示comman-not-found怎么回事"><a href="#1-1-重启后nvcc-V显示comman-not-found怎么回事" class="headerlink" title="1.1 重启后nvcc -V显示comman not found怎么回事"></a>1.1 重启后<code>nvcc -V</code>显示comman not found怎么回事</h3><p>如果是自己的电脑,建议直接将环境变量设置在<code>/etc/profile</code>里面,一劳永逸.也不会因为弃用bash(安装了zsh的情况下),导致~/.bashrc里面的环境变量失效.</p>
<h2 id="2-Cudnn的安装"><a href="#2-Cudnn的安装" class="headerlink" title="2 Cudnn的安装"></a>2 Cudnn的安装</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo cp /usr/local/cuda-11.1/lib64/libcusolver.so.11 /usr/local/cuda-11.1/lib64/libcusolver.so.10</span><br></pre></td></tr></table></figure>

<p>上面这行命令可能随着安装的版本不同而改变,在Jupyter里面运行下面这段代码</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line">devices = tf.config.list_physical_devices()</span><br><span class="line"><span class="built_in">print</span>(devices)</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://naixil.github.io/2021/08/31/2PythonStudy/Py-2-Jupyter/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Li Xian">
      <meta itemprop="description" content="与遗忘作斗争">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LiXian's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/31/2PythonStudy/Py-2-Jupyter/" class="post-title-link" itemprop="url">Py-2-Jupyter</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-08-31 16:00:15" itemprop="dateCreated datePublished" datetime="2021-08-31T16:00:15+08:00">2021-08-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-09-02 11:13:47" itemprop="dateModified" datetime="2021-09-02T11:13:47+08:00">2021-09-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python/" itemprop="url" rel="index"><span itemprop="name">Python</span></a>
                </span>
            </span>

          
            <span id="/2021/08/31/2PythonStudy/Py-2-Jupyter/" class="post-meta-item leancloud_visitors" data-flag-title="Py-2-Jupyter" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/08/31/2PythonStudy/Py-2-Jupyter/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/08/31/2PythonStudy/Py-2-Jupyter/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="jupyter篇"><a href="#jupyter篇" class="headerlink" title="jupyter篇"></a>jupyter篇</h1><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><ul>
<li>jupyter notebook 移除虚拟环境<code>jupyter kernelspec remove XXX</code></li>
<li>pip3 install –user  jupyter -i <a target="_blank" rel="noopener" href="http://pypi.douban.com/simple/">http://pypi.douban.com/simple/</a> –trusted-host pypi.douban.com</li>
<li>nbconvert<ul>
<li>命令行运行：<ul>
<li>ipython nbconvert –to notebook –execute plot.ipynb –output output.ipynb # 输出运行结果到output.ipynb/html</li>
<li>–to python/pdf/html/notebook # 转换成对应的文件</li>
</ul>
</li>
</ul>
</li>
<li>nohup command &gt; output.log 2&gt;&amp;1 &amp;<ul>
<li>tail -f filename # 实时查看输出</li>
<li>jobs查看nohup进程</li>
</ul>
</li>
</ul>
<h2 id="Jupyter显示完整数组"><a href="#Jupyter显示完整数组" class="headerlink" title="Jupyter显示完整数组"></a>Jupyter显示完整数组</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.set_printoptions(threshold=np.inf)</span><br></pre></td></tr></table></figure>

<h1 id="WSL下jupyter-notebook安装、访问"><a href="#WSL下jupyter-notebook安装、访问" class="headerlink" title="WSL下jupyter notebook安装、访问"></a>WSL下jupyter notebook安装、访问</h1><h2 id="文档适用"><a href="#文档适用" class="headerlink" title="文档适用"></a>文档适用</h2><ul>
<li>Windows10环境已安装WSL2下的Ubuntu20.04</li>
<li>WSL2<ul>
<li>Ubuntu20.04（没桌面的那种）</li>
<li>python3.8.5</li>
<li>pip 20.0.2</li>
</ul>
</li>
</ul>
<h2 id="安装流程"><a href="#安装流程" class="headerlink" title="安装流程"></a>安装流程</h2><p><strong>以下为安装步骤：</strong></p>
<ol>
<li><p>pip install jupyter notebook</p>
</li>
<li><p>jupyter notebook –generate-config</p>
<ol>
<li>这一步会生成一个jupyternotebook的配置文件文件位置在(如果是root用户登录)：’/root/.jupyter/jupyter_notebook_config.py’</li>
</ol>
</li>
<li><p>jupyter notebook password # 这里会要求你输入并确认密码，回车</p>
<ol>
<li>[NotebookPasswordApp] Wrote hashed password to root/.jupyter/jupyter_notebook_config.json</li>
<li>vim /root/.jupyter\jupyter_notebook_config.json<ol>
<li>复制里面单引号的乱码，那个就是加密后的密码</li>
</ol>
</li>
</ol>
</li>
<li><p>设置你windows电脑的浏览器能打开jupyternotebook</p>
<ol>
<li>我这里安装的是EDGE DEV版本的浏览器，Windows中路径为C:\Program Files (x86)\Microsoft\Edge Dev\Application\msedge.exe</li>
<li>那么在WSL2的Ubuntu里面，这个路径就是：/mnt/c/Program\ Files\ (x86)/Microsoft/Edge\ Dev/Application/msedge.exe，可以在Ubuntu里面不断TAB补全路径试一下，其中路径中的空格和括号（）在输入之前都要打一个反斜杠\，才能行得通</li>
<li>创建软连接：ln -sf /mnt/c/Program\ Files\ (x86)/Microsoft/Edge\ Dev/Application/msedge.exe /usr/bin/msedge</li>
<li>上面这三个小的三步完成之后，你再Ubuntu终端里直接输入msedge能直接打开你的Windows的EDGE DEV浏览器</li>
</ol>
</li>
<li><p>vim /root/.jupyter/jupyter_notebook_config.py # 打开这个文件搜索文件的内容按如下步骤修改，VIM里面命令模式（:/XXX）是搜索，比如我想搜字符串2021，那我就可以转到命令模式（就是有冒号的那个），然后输入/2021，再Enter，n是下一个，N是上一个</p>
<ol>
<li>c.NotebookApp.ip = ‘*’</li>
<li>c.NotebookApp.allow_remote_access = True # 允许远程访问</li>
<li>c.NotebookApp.allow_root = True # 允许root用户登录</li>
<li>c.NotebookApp.notebook_dir = ‘/root/Projects’ # 里面的文件夹可以自定义为自己想要的项目文件夹</li>
<li>c.NotebookApp.use_redirect_file = False</li>
<li>c.NotebookApp.password = ‘此处填写3-2-1步骤生成的password’</li>
<li>把Windows的EDGE DEV作为Ubuntu的默认浏览器<ol>
<li>import webbrowser</li>
<li>webbrowser.register(‘msedge’,None,webbrowser.GenericBrowser(‘/usr/bin/msedge’))</li>
<li>c.NotebookApp.browser=’msedge’<img src="/2021/08/31/2PythonStudy/Py-2-Jupyter/image-20210206135856519.png" alt="image-20210206135856519" style="zoom: 33%;"></li>
</ol>
</li>
<li>换命令模式 wq!退出</li>
</ol>
</li>
<li><p>输入jupyter notebook 此时你的EDGE浏览器会访问localhost:8888/tree，这里我配置的时候显示</p>
<img src="/2021/08/31/2PythonStudy/Py-2-Jupyter/image-20210206140917586.png" alt="image-20210206140917586" style="zoom:33%;"></li>
</ol>
<p><strong>这里我也不知道为啥，有知道的欢迎告知。</strong></p>
<p>我的解决办法就是在ubuntu终端里面输入ifconfig查看当前WSL的ip地址，比如我的是</p>
<img src="/2021/08/31/2PythonStudy/Py-2-Jupyter/image-20210206141119912.png" alt="image-20210206141119912" style="zoom:33%;">

<p>那么就把localhost换成IP地址172.27.118.134就行了，如下图就可以访问了。</p>
<img src="/2021/08/31/2PythonStudy/Py-2-Jupyter/image-20210206141244301.png" alt="image-20210206141244301" style="zoom:50%;">

<h2 id="多虚拟环境配置"><a href="#多虚拟环境配置" class="headerlink" title="多虚拟环境配置"></a>多虚拟环境配置</h2><p>这里不推荐安装virtualenvwrapper，降低学习成本，而且安装了jupyter notebook之后也不需要频繁激活虚拟环境。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">pip install virtualenv </span><br><span class="line"><span class="comment"># 在/root（这里笔者以root用户登录的）文件夹下新建一个Virtualevs的文件夹用来存放虚拟环境</span></span><br><span class="line">mkdir /root/Virtualenvs</span><br><span class="line">cd /root/Virtualenvs</span><br><span class="line"><span class="comment"># 建立虚拟环境名字为‘tensorflow’</span></span><br><span class="line">virtualenv -p /usr/<span class="built_in">bin</span>/python3<span class="number">.8</span> tensorflow</span><br><span class="line"><span class="comment"># 激活虚拟环境配置jupyter notebook</span></span><br><span class="line">source /root/Virtualenvs/tensorflow/<span class="built_in">bin</span>/avtivate</span><br><span class="line"><span class="comment"># 这里终端应该是类似（tensorflow）...# 这种的形式，就说明进入到了虚拟环境，可以pip list查看一下安装的包，应该是 之后setuptools什么的</span></span><br><span class="line">ModuleNotFoundError: No module named <span class="string">&#x27;jupyter_nbextensions_configurator&#x27;</span></span><br><span class="line">python -m ipykernel install --name tensorflow --display-name tensorflow</span><br><span class="line"><span class="comment"># 再打开jupyter notebook之后就可以在new那里看到新建的虚拟环境了</span></span><br><span class="line">jupyter notebook</span><br><span class="line"><span class="comment"># 而且这样之后即使deactivate虚拟环境之后，在基础的那个环境里面打开jupyter notebook之后也可以选择虚拟环境</span></span><br></pre></td></tr></table></figure>

<p>扩展安装</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pip install jupyter_contrib_nbextensions -i https://mirrors.tuna.tsinghua.edu.cn/pypi/web/simple/ </span><br><span class="line">jupyter contrib nbextension install  --user</span><br><span class="line">pip install jupyter_nbextensions_configurator -i https://mirrors.tuna.tsinghua.edu.cn/pypi/web/simple/</span><br><span class="line">jupyter nbextensions_configurator <span class="built_in">enable</span> --user</span><br><span class="line"><span class="comment"># 这之后就可以看到Nbextension，复选框选择哪个就是激活哪个</span></span><br></pre></td></tr></table></figure>

<img src="/2021/08/31/2PythonStudy/Py-2-Jupyter/image-20210206144358079.png" alt="image-20210206144358079" style="zoom: 25%;">

<h1 id="浪潮jupyter访问："><a href="#浪潮jupyter访问：" class="headerlink" title="浪潮jupyter访问："></a>浪潮jupyter访问：</h1><h2 id="新建开发环境"><a href="#新建开发环境" class="headerlink" title="新建开发环境"></a>新建开发环境</h2><p>使用tmux命令启动一个新的会话运行<code>jupyter lab</code></p>
<p>依次输入如下命令：</p>
<p><img src="/2021/08/31/2PythonStudy/Py-2-Jupyter/image-20210730143240613.png" alt="image-20210730143240613"></p>
<img src="/2021/08/31/2PythonStudy/Py-2-Jupyter/image-20210730143309274.png" alt="image-20210730143309274" style="zoom:50%;">

<p>记住jupyter的端口号：8888</p>
<p>tmux的返回原来的终端：先按下Ctrl+B 再按下D，其他命令自行网络搜索。</p>
<p>首先在本机的浏览器输入开发环境8888端口对应的101.7.186.128的端口（也即浏览器打开101.7.186.128:57663/），查看8888端口对应的浪潮主机端口方式见下图：</p>
<img src="/2021/08/31/2PythonStudy/Py-2-Jupyter/image-20210730144015314.png" alt="image-20210730144015314" style="zoom:33%;">

<p>能打开则代表可以连接上。（默认密码是123，更改方式可以在开发环境的shell里面输入，<code>jupyter server password</code>进行更改）</p>
<img src="/2021/08/31/2PythonStudy/Py-2-Jupyter/image-20210730144440658.png" alt="image-20210730144440658" style="zoom:33%;">

<p>如果打不开的话，转第二节：</p>
<img src="/2021/08/31/2PythonStudy/Py-2-Jupyter/image-20210730144233395.png" alt="image-20210730144233395" style="zoom:50%;">

<h2 id="本地cmd操作"><a href="#本地cmd操作" class="headerlink" title="本地cmd操作"></a>本地cmd操作</h2><p>本机的命令行界面输入：</p>
<p><code>ssh -p 42239  -N -f -L localhost:8889:localhost:8888 root@101.7.186.128</code></p>
<p>其中：42239为开发环境的ssh端口，查看方法看下图。</p>
<p>回车之后会让输入密码，如果下图显示的密码不对，在开发环境的终端里面输入<code>passwd</code>，改个密码再输入。</p>
<p><img src="/2021/08/31/2PythonStudy/Py-2-Jupyter/image-20210730142918765.png" alt="image-20210730142918765"></p>
<p>回车之后不显示密码错误，代表已经建立连接了。下面的这个终端不要退出，需要保持连接。</p>
<p><img src="/2021/08/31/2PythonStudy/Py-2-Jupyter/image-20210730143822009.png" alt="image-20210730143822009"></p>
<p>此时，在本机浏览器输入<a target="_blank" rel="noopener" href="http://localhost:8889/">http://localhost:8889/</a></p>
<img src="/2021/08/31/2PythonStudy/Py-2-Jupyter/image-20210730144312561.png" alt="image-20210730144312561" style="zoom:33%;">



<h1 id="Jupyter-Lab"><a href="#Jupyter-Lab" class="headerlink" title="Jupyter Lab"></a>Jupyter Lab</h1><h2 id="nodejs安装"><a href="#nodejs安装" class="headerlink" title="nodejs安装"></a>nodejs安装</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dnf module list nodejs</span><br><span class="line">dnf module reset nodejs  # 如果不能安装的话</span><br><span class="line">dnf module install nodejs:12</span><br></pre></td></tr></table></figure>

<p> <code>ssh -p 22651 -N -f -L localhost:8888:localhost:8890 root@219.150.218.20</code></p>
<h2 id="Jupyter-Lab插件推荐"><a href="#Jupyter-Lab插件推荐" class="headerlink" title="Jupyter Lab插件推荐"></a>Jupyter Lab插件推荐</h2><p>插件安装<code>jupyter labextension install @telamonian/theme-darcula</code></p>
<p><a target="_blank" rel="noopener" href="https://github.com/jtpio/jupyterlab-python-file">jupyterlab-python-file</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/krassowski/jupyterlab-lsp">@krassowski/jupyterlab-lsp</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/epi2me-labs/jupyterlab-code-cell-collapser">@epi2melabs/jupyterlab-code-cell-collapser</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/telamonian/theme-darcula">@telamonian/theme-darcula</a></p>
<p>@krassowski/jupyterlab_go_to_definition</p>
<p><a target="_blank" rel="noopener" href="https://github.com/johnnybarrels/jupyterlab_onedarkpro">jupyterlab_onedarkpro</a></p>
<h2 id="插件快捷键"><a href="#插件快捷键" class="headerlink" title="插件快捷键"></a>插件快捷键</h2><h3 id="krassowski-jupyterlab-go-to-definition"><a href="#krassowski-jupyterlab-go-to-definition" class="headerlink" title="@krassowski/jupyterlab_go_to_definition"></a>@krassowski/jupyterlab_go_to_definition</h3><ul>
<li>查看变量定义<ul>
<li>Alt + 点击</li>
<li>Ctrl + Alt + B</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Li Xian</p>
  <div class="site-description" itemprop="description">与遗忘作斗争</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">32</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/naixil" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;naixil" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:lixian_shandong@126.com" title="E-Mail → mailto:lixian_shandong@126.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Li Xian</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">134k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">2:02</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>






<script>
  (function() {
    function leancloudSelector(url) {
      url = encodeURI(url);
      return document.getElementById(url).querySelector('.leancloud-visitors-count');
    }

    function addCount(Counter) {
      var visitors = document.querySelector('.leancloud_visitors');
      var url = decodeURI(visitors.id);
      var title = visitors.dataset.flagTitle;

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url })))
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length > 0) {
            var counter = results[0];
            leancloudSelector(url).innerText = counter.time + 1;
            Counter('put', '/classes/Counter/' + counter.objectId, { time: { '__op': 'Increment', 'amount': 1 } })
              .catch(error => {
                console.error('Failed to save visitor count', error);
              });
          } else {
              leancloudSelector(url).innerText = 'Counter not initialized! More info at console err msg.';
              console.error('ATTENTION! LeanCloud counter has security bug, see how to solve it here: https://github.com/theme-next/hexo-leancloud-counter-security. \n However, you can still use LeanCloud without security, by setting `security` option to `false`.');
            
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    function showTime(Counter) {
      var visitors = document.querySelectorAll('.leancloud_visitors');
      var entries = [...visitors].map(element => {
        return decodeURI(element.id);
      });

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url: { '$in': entries } })))
        .then(response => response.json())
        .then(({ results }) => {
          for (let url of entries) {
            let target = results.find(item => item.url === url);
            leancloudSelector(url).innerText = target ? target.time : 0;
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    let { app_id, app_key, server_url } = {"enable":true,"app_id":"L0cX6ObLkHnV1ydxDWqlN8Ys-gzGzoHsz","app_key":"wsWU6zzETUob4rOLeRJBp0sv","server_url":null,"security":true};
    function fetchData(api_server) {
      var Counter = (method, url, data) => {
        return fetch(`${api_server}/1.1${url}`, {
          method,
          headers: {
            'X-LC-Id'     : app_id,
            'X-LC-Key'    : app_key,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };
      if (CONFIG.page.isPost) {
        if (CONFIG.hostname !== location.hostname) return;
        addCount(Counter);
      } else if (document.querySelectorAll('.post-title-link').length >= 1) {
        showTime(Counter);
      }
    }

    let api_server = app_id.slice(-9) !== '-MdYXbMMI' ? server_url : `https://${app_id.slice(0, 8).toLowerCase()}.api.lncldglobal.com`;

    if (api_server) {
      fetchData(api_server);
    } else {
      fetch('https://app-router.leancloud.cn/2/route?appId=' + app_id)
        .then(response => response.json())
        .then(({ api_server }) => {
          fetchData('https://' + api_server);
        });
    }
  })();
</script>


      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : true,
      appId      : 'L0cX6ObLkHnV1ydxDWqlN8Ys-gzGzoHsz',
      appKey     : 'wsWU6zzETUob4rOLeRJBp0sv',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
